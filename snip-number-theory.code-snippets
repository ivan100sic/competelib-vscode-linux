{
	"Extended Euclidean Algorithm": {
		"scope": "cpp",
		"prefix": "eea",
		"body": [
			"template<class T>",
			"T eea(T a, T b, T& x, T& y) {",
			"\tif (!b) {",
			"\t\tx = 1;",
			"\t\ty = 0;",
			"\t\treturn a;",
			"\t}",
			"",
			"\tT x1, y1;",
			"\tT g = eea(b, a % b, x1, y1);",
			"\tx = y1;",
			"\ty = x1 - (a / b) * y1;",
			"\treturn g;",
			"}"
		]
	},

	"Chinese Remainder Theorem": {
		"scope": "cpp",
		"prefix": "crt",
		"body": [
			"struct crt {",
			"\tll i1, i2, mm, mod1, mod2;",
			"",
			"\t// mod1 * mod2 < 2^62",
			"\tcrt(ll mod1, ll mod2) {",
			"\t\tthis->mod1 = mod1;",
			"\t\tthis->mod2 = mod2;",
			"\t\teea(mod1, mod2, i1, i2);",
			"\t\tmm = mod1 * mod2;",
			"\t\ti1 = (i1 % mm + mm) % mm;",
			"\t\ti2 = (i2 % mm + mm) % mm;",
			"\t}",
			"",
			"\tll operator() (ll x, ll y) const {",
			"\t\tx = (__int128_t)x * i2 % mm;",
			"\t\ty = (__int128_t)y * i1 % mm;",
			"\t\tll t = (__int128_t)x * mod2 % mm + (__int128_t)y * mod1 % mm;",
			"\t\treturn t >= mm ? t - mm : t;",
			"\t}",
			"};"
		]
	},

	"Sieve of Eratosthenes": {
		"scope": "cpp",
		"prefix": "sieve",
		"body": [
			"struct sieve {",
			"\tconst int maxn;",
			"\tvector<int> f, primes;",
			"",
			"\tsieve(int maxn) : maxn(maxn), f(maxn) {",
			"\t\tfor (int i=2; i<maxn; i++) {",
			"\t\t\tif (f[i] == 0) {",
			"\t\t\t\tf[i] = i;",
			"\t\t\t\tprimes.push_back(i);",
			"\t\t\t}",
			"",
			"\t\t\tfor (int p : primes) {",
			"\t\t\t\tif (p > f[i] || i * p >= maxn) {",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"",
			"\t\t\t\tf[i*p] = p;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			" \tauto factor_small(int x) const {",
			"\t\tvector<pair<int, int>> v;",
			"\t\twhile (x > 1) {",
			"\t\t\tint p = f[x], c = 0;",
			"\t\t\twhile (x % p == 0) {",
			"\t\t\t\tx /= p;",
			"\t\t\t\tc++;",
			"\t\t\t}",
			"\t\t\tv.emplace_back(p, c);",
			"\t\t}",
			"\t\treturn v;",
			"\t}",
			"",
			"\ttemplate<class T>",
			"\tauto factor(T x) const {",
			"\t\tvector<pair<T, int>> v;",
			"\t\tfor (int p : primes) {",
			"\t\t\tif ((ll)p*p > x) {",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"",
			"\t\t\tif (x % p == 0) {",
			"\t\t\t\tint c = 0;",
			"\t\t\t\twhile (x % p == 0) {",
			"\t\t\t\t\tx /= p;",
			"\t\t\t\t\tc++;",
			"\t\t\t\t}",
			"\t\t\t\tv.emplace_back(p, c);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (x > 1) {",
			"\t\t\tv.emplace_back(x, 1);",
			"\t\t}",
			"",
			"\t\treturn v;",
			"\t}",
			"};"
		]
	},

	"Modular arithmetic": {
		"scope": "cpp",
		"prefix": "mint",
		"body": [
			"template<int m>",
			"struct modint {",
			"\tunsigned x;",
			"",
			"\tmodint() : x(0) {}",
			"\tmodint(long long arg) : x((arg %= m) < 0 ? arg + m : arg) {}",
			"",
			"\tmodint operator+ (const modint& b) const {",
			"\t\tauto t = *this; t.x = (t.x += b.x) >= m ? t.x-m : t.x; return t;",
			"\t}",
			"",
			"\tmodint operator- (const modint& b) const {",
			"\t\tauto t = *this; t.x = (t.x += m-b.x) >= m ? t.x-m : t.x; return t;",
			"\t}",
			"",
			"\tmodint operator* (const modint& b) const {",
			"\t\tauto t = *this; t.x = ll(t.x) * b.x % m; return t;",
			"\t}",
			"",
			"\tmodint operator/ (const modint& b) const {",
			"\t\treturn *this * b.inv();",
			"\t}",
			"",
			"\ttemplate<class T> modint operator^ (T n) const {",
			"\t\tmodint t;",
			"\t\tif (n == 0) return t.x = 1, t;",
			"\t\tif (n == 1) return t.x = x, t;",
			"\t\tt = *this ^ (n >> 1); t *= t;",
			"\t\treturn n & 1 ? *this * t : t;",
			"\t}",
			"",
			"\tmodint& operator+= (const modint& b) { return *this = *this + b; }",
			"\tmodint& operator-= (const modint& b) { return *this = *this - b; }",
			"\tmodint& operator*= (const modint& b) { return *this = *this * b; }",
			"\tmodint& operator/= (const modint& b) { return *this = *this / b; }",
			"\tmodint& operator++ () { if (++x == m) x = 0; return *this; }",
			"\tmodint& operator-- () { if (x-- == 0) x = m-1; return *this; }",
			"\tmodint operator++ (int) { modint tmp = *this; ++*this; return tmp; }",
			"\tmodint operator-- (int) { modint tmp = *this; --*this; return tmp; }",
			"\tbool operator== (const modint& other) const { return x == other.x; }",
			"\tbool operator!= (const modint& other) const {\treturn x != other.x; }",
			"\tint operator() () const { return x; }",
			"\ttemplate<class T> modint operator^= (T n) { return *this = *this ^ n; }",
			"\tmodint inv() const { return *this ^ (m-2); }",
			"};",
			"",
			"const int mod = 1'000'000'007;",
			"typedef modint<mod> mint;"
		]
	}
}
