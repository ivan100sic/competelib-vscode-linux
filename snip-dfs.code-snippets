{
	"Dominator tree": {
		"scope": "cpp",
		"prefix": "dominatortree",
		"body": [
			"struct dominator_tree {",
			"\tvector<basic_string<int>> g, rg, bucket;",
			"\tvector<int> arr, par, rev, sdom, dom, dsu, label;",
			"\tint n, t;",
			"\tdominator_tree(int n) : g(n), rg(n), bucket(n), arr(n, -1),",
			"\t\tpar(n), rev(n), sdom(n), dom(n), dsu(n), label(n), n(n), t(0) {}",
			"\tvoid add_edge(int u, int v) { g[u] += v; }",
			"\tvoid dfs(int u) {",
			"\t\tarr[u] = t;",
			"\t\trev[t] = u;",
			"\t\tlabel[t] = sdom[t] = dsu[t] = t;",
			"\t\tt++;",
			"\t\tfor (int w : g[u]) {",
			"\t\t\tif (arr[w] == -1) {",
			"\t\t\t\tdfs(w);",
			"\t\t\t\tpar[arr[w]] = arr[u];",
			"\t\t\t}",
			"\t\t\trg[arr[w]] += arr[u];",
			"\t\t}",
			"\t}",
			"\tint find(int u, int x=0) {",
			"\t\tif (u == dsu[u])",
			"\t\t\treturn x ? -1 : u;",
			"\t\tint v = find(dsu[u], x+1);",
			"\t\tif (v < 0)",
			"\t\t\treturn u;",
			"\t\tif (sdom[label[dsu[u]]] < sdom[label[u]])",
			"\t\t\tlabel[u] = label[dsu[u]];",
			"\t\tdsu[u] = v;",
			"\t\treturn x ? v : label[u];",
			"\t}",
			"\tvector<int> run(int root = 0) {",
			"\t\tdfs(root);",
			"\t\tiota(dom.begin(), dom.end(), 0);",
			"\t\tfor (int i=t-1; i>=0; i--) {",
			"\t\t\tfor (int w : rg[i])",
			"\t\t\t\tsdom[i] = min(sdom[i], sdom[find(w)]);",
			"\t\t\tif (i)",
			"\t\t\t\tbucket[sdom[i]] += i;",
			"\t\t\tfor (int w : bucket[i]) {",
			"\t\t\t\tint v = find(w);",
			"\t\t\t\tif (sdom[v] == sdom[w])",
			"\t\t\t\t\tdom[w] = sdom[w];",
			"\t\t\t\telse",
			"\t\t\t\t\tdom[w] = v;",
			"\t\t\t}",
			"\t\t\tif (i > 1)",
			"\t\t\t\tdsu[i] = par[i];",
			"\t\t}",
			"\t\tfor (int i=1; i<t; i++) {",
			"\t\t\tif (dom[i] != sdom[i])",
			"\t\t\t\tdom[i] = dom[dom[i]];",
			"\t\t}",
			"\t\tvector<int> outside_dom(n);",
			"\t\tiota(begin(outside_dom), end(outside_dom), 0);",
			"\t\tfor (int i=0; i<t; i++)",
			"\t\t\toutside_dom[rev[i]] = rev[dom[i]];",
			"\t\treturn outside_dom;",
			"\t}",
			"};"
		]
	},

	"Strongly connected components": {
		"scope": "cpp",
		"prefix": "scc",
		"body": [
			"struct scc {",
			"\tvector<vector<int>> e;",
			"\tvector<int> i, l, s;",
			"\tstring p;",
			"\tint t;",
			"",
			"\tscc(int n) : e(n) {}",
			"",
			"\tvoid init() {",
			"\t\ti = l = vector<int>(e.size());",
			"\t\tp = string(e.size(), 0);",
			"\t\tt = 0;",
			"\t}",
			"",
			"\tvoid add_edge(int x, int y) {",
			"\t\te[x].push_back(y);",
			"\t}",
			"",
			"\ttemplate<class B, class A>",
			"\tvoid dfs(int x, B b, A a) {",
			"\t\ti[x] = l[x] = ++t;",
			"\t\ts.push_back(x);",
			"\t\tp[x] = 1;",
			"\t\tfor (int y : e[x]) {",
			"\t\t\tif (!i[y]) {",
			"\t\t\t\tdfs(y, b, a);",
			"\t\t\t\tl[x] = min(l[x], l[y]);",
			"\t\t\t} else if (p[y]) {",
			"\t\t\t\tl[x] = min(l[x], i[y]);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (i[x] == l[x]) {",
			"\t\t\tb();",
			"\t\t\twhile (1) {",
			"\t\t\t\tint y = s.back();",
			"\t\t\t\ts.pop_back();",
			"\t\t\t\tp[y] = 0;",
			"\t\t\t\ta(y);",
			"\t\t\t\tif (y == x) break;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\ttemplate<class B, class A>",
			"\tvoid run(B b, A a) {",
			"\t\tfor (int x=0; x<(int)e.size(); x++) {",
			"\t\t\tif (!i[x]) {",
			"\t\t\t\tdfs(x, b, a);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvector<vector<int>> components() {",
			"\t\tinit();",
			"\t\tvector<vector<int>> z;",
			"\t\trun([&]() { z.emplace_back(); }, [&](int x) { z.back().push_back(x); });",
			"\t\treturn z;",
			"\t}",
			"",
			"\tvector<int> colors() {",
			"\t\tinit();",
			"\t\tvector<int> c = i;",
			"\t\tint k = -1;",
			"\t\trun([&]() { k++; }, [&](int x) { c[x] = k; });",
			"\t\treturn c;",
			"\t}",
			"};"
		]
	},

	"Bridges (2-edge connected components)": {
		"scope": "cpp",
		"prefix": "bridges",
		"body": [
			"struct bridges {",
			"\tvector<vector<int>> e;",
			"\tvector<int> i, l, s;",
			"\tint t;",
			"",
			"\t// Multiple edges are supported",
			"\tbridges(int n) : e(n) {}",
			"",
			"\tvoid init() {",
			"\t\ti = l = vector<int>(e.size());",
			"\t\tt = 0;",
			"\t}",
			"",
			"\tvoid add_edge(int x, int y) {",
			"\t\te[x].push_back(y);",
			"\t\te[y].push_back(x);",
			"\t}",
			"",
			"\ttemplate<class B, class A>",
			"\tvoid dfs(int x, int p, B b, A a) {",
			"\t\ti[x] = l[x] = ++t;",
			"\t\ts.push_back(x);",
			"\t\tbool c = 1;",
			"\t\tfor (int y : e[x]) {",
			"\t\t\tif (c && y == p) {",
			"\t\t\t\tc = 0;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"",
			"\t\t\tif (!i[y]) {",
			"\t\t\t\tdfs(y, x, b, a);",
			"\t\t\t\tl[x] = min(l[x], l[y]);",
			"\t\t\t} else {",
			"\t\t\t\tl[x] = min(l[x], i[y]);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (i[x] == l[x]) {",
			"\t\t\tb();",
			"\t\t\twhile (1) {",
			"\t\t\t\tint z = s.back();",
			"\t\t\t\ts.pop_back();",
			"\t\t\t\ta(z);",
			"\t\t\t\tif (z == x) break;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\ttemplate<class B, class A>",
			"\tvoid run(B b, A a) {",
			"\t\tfor (int x=0; x<(int)e.size(); x++) {",
			"\t\t\tif (!i[x]) {",
			"\t\t\t\tdfs(x, -1, b, a);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvector<vector<int>> components() {",
			"\t\tinit();",
			"\t\tvector<vector<int>> z;",
			"\t\trun([&]() { z.emplace_back(); }, [&](int x) { z.back().push_back(x); });",
			"\t\treturn z;",
			"\t}",
			"",
			"\tvector<int> colors() {",
			"\t\tinit();",
			"\t\tvector<int> c = i;",
			"\t\tint k = -1;",
			"\t\trun([&]() { k++; }, [&](int x) { c[x] = k; });",
			"\t\treturn c;",
			"\t}",
			"};"
		]
	},

	"Articulation vertices (2-vertex CCs)": {
		"scope": "cpp",
		"prefix": "articulationvertices",
		"body": [
			"struct articulation_vertices {",
			"\tvector<vector<int>> e;",
			"\tvector<pair<int, int>> b;",
			"\tvector<int> i, l, s, c;",
			"\tint k, t;",
			"",
			"\t// Multiple edges are supported",
			"\tarticulation_vertices(int n, const vector<pair<int, int>>& g) :",
			"\t\te(n), i(n), l(n), c(g.size()), k(0), t(0)",
			"\t{",
			"\t\tb = g;",
			"\t\tfor (int i=0; i<(int)b.size(); i++) {",
			"\t\t\tauto [x, y] = b[i];",
			"\t\t\te[x].push_back(i);",
			"\t\t\te[y].push_back(i);",
			"\t\t}",
			"",
			"\t\tfor (int x=0; x<(int)e.size(); x++) {",
			"\t\t\tif (!i[x]) {",
			"\t\t\t\tdfs(x, -1);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid dfs(int x, int p) {",
			"\t\ti[x] = l[x] = ++t;",
			"\t\tint q = 1;",
			"\t\tfor (int m : e[x]) {",
			"\t\t\tint y = b[m].first ^ b[m].second ^ x;",
			"\t\t\tif (q && y == p) {",
			"\t\t\t\tq = 0;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tif (i[y]) {",
			"\t\t\t\tif (i[y] < i[x]) {",
			"\t\t\t\t\tl[x] = min(l[x], i[y]);",
			"\t\t\t\t\ts.push_back(m);",
			"\t\t\t\t}",
			"\t\t\t} else {",
			"\t\t\t\ts.push_back(m);",
			"\t\t\t\tdfs(y, x);",
			"\t\t\t\tl[x] = min(l[x], l[y]);",
			"\t\t\t\tif (l[y] >= i[x]) {",
			"\t\t\t\t\twhile (1) {",
			"\t\t\t\t\t\tint j = s.back();",
			"\t\t\t\t\t\ts.pop_back();",
			"\t\t\t\t\t\tc[j] = k;",
			"\t\t\t\t\t\tif (j == m) {",
			"\t\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\tk++;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tconst vector<int>& colors() const { return c; }",
			"",
			"\tvector<int> vertices() {",
			"\t\tvector<int> r;",
			"\t\tfor (int x=0; x<(int)e.size(); x++) {",
			"\t\t\tint z = -1;",
			"\t\t\tfor (int i : e[x]) {",
			"\t\t\t\tz = z == -1 ? c[i] : (z == c[i] ? z : -2);",
			"\t\t\t}",
			"\t\t\tif (z == -2) {",
			"\t\t\t\tr.push_back(x);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn r;",
			"\t}",
			"};"
		]
	}
}
