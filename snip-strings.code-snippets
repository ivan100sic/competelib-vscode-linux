{
	"Aho-Corasick automaton": {
		"scope": "cpp",
		"prefix": "ahocorasick",
		"body": [
			"struct ahocorasick {",
			"\tstruct node {",
			"\t\tmap<char, int> next, hop;",
			"\t\tint link{0};",
			"\t};",
			"\tvector<node> b;",
			"\tbool done;",
			"\tahocorasick() : b(1), done(false) {}",
			"\tint size() const { return b.size(); }",
			"",
			"\tint operator+= (const string& s) {",
			"\t\tint y = 0;",
			"\t\tfor (char x : s) {",
			"\t\t\tauto it = b[y].next.find(x);",
			"\t\t\tif (it == b[y].next.end()) {",
			"\t\t\t\tit = b[y].next.insert(it, {x, b.size()});",
			"\t\t\t\tb.emplace_back();",
			"\t\t\t}",
			"\t\t\ty = it->second;",
			"\t\t}",
			"\t\tdone = false;",
			"\t\treturn y;",
			"\t}",
			"",
			"\tvoid bfs() {",
			"\t\tb[0].link = -1;",
			"\t\tvector<int> q(b.size());",
			"\t\tsize_t qs = 0, qe = 1;",
			"\t\twhile (qs != qe) {",
			"\t\t\tint x = q[qs++];",
			"\t\t\tfor (auto [c, y] : b[x].next) {",
			"\t\t\t\tint t = b[x].link;",
			"\t\t\t\twhile (t != -1 && !b[t].next.count(c))",
			"\t\t\t\t\tt = b[t].link;",
			"\t\t\t\tb[y].link = t != -1 ? b[t].next[c] : 0;",
			"\t\t\t\tq[qe++] = y;",
			"\t\t\t}",
			"\t\t}",
			"\t\tdone = true;",
			"\t}",
			"",
			"\tint operator() (int x, char c) {",
			"\t\tif (!done) bfs();",
			"\t\tauto it = b[x].hop.find(c);",
			"\t\tif (it == b[x].hop.end()) {",
			"\t\t\tint t = x;",
			"\t\t\twhile (t >= 0 && b[t].next.count(c) == 0)",
			"\t\t\t\tt = b[t].link;",
			"\t\t\tit = b[x].hop.insert(it, {c, t == -1 ? 0 : b[t].next[c]});",
			"\t\t}",
			"\t\treturn it->second;",
			"\t}",
			"};"
		]
	},

	"Suffix automaton": {
		"scope": "cpp",
		"prefix": "suffixautomaton",
		"body": [
			"template<class T = char>",
			"struct suffix_automaton {",
			"\tstruct node {",
			"\t\tmap<T, int> next;",
			"\t\tint link, len;",
			"\t\tbool cl;",
			"\t};",
			"",
			"\tvector<node> b;",
			"\tvector<int> _topo;",
			"",
			"\ttemplate<class U>",
			"\tsuffix_automaton(const U& s) {",
			"\t\tb.push_back({{}, -1, 0, false});",
			"\t\tint last = 0;",
			"\t\tfor (T x : s)",
			"\t\t\tlast = extend(x, last);",
			"\t}",
			"",
			"\tnode& operator[](int x) {",
			"\t\treturn b[x];",
			"\t}",
			"",
			"\tint extend(T x, int last) {",
			"\t\tint curr = b.size();",
			"\t\tb.emplace_back();",
			"\t\tb[curr].len = b[last].len + 1;",
			"\t\tint p = last;",
			"\t\tfor (; p != -1 && !b[p].next.count(x); p = b[p].link)",
			"\t\t\tb[p].next[x] = curr;",
			"\t\tif (p == -1) {",
			"\t\t\tb[curr].link = 0;",
			"\t\t} else {",
			"\t\t\tint q = b[p].next[x];",
			"\t\t\tif (b[p].len + 1 == b[q].len) {",
			"\t\t\t\tb[curr].link = q;",
			"\t\t\t} else {",
			"\t\t\t\tint clone = b.size();",
			"\t\t\t\tb.emplace_back(b[q]);",
			"\t\t\t\tb[clone].len = b[p].len + 1;",
			"\t\t\t\tb[clone].cl = true;",
			"\t\t\t\tfor (; p != -1 && b[p].next[x] == q; p = b[p].link)",
			"\t\t\t\t\tb[p].next[x] = clone;",
			"\t\t\t\tb[curr].link = b[q].link = clone;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn curr;",
			"\t}",
			"",
			"\tint operator()(int x, T y) {",
			"\t\tif (x == -1) return -1;",
			"\t\tauto it = b[x].next.find(y);",
			"\t\treturn it == b[x].next.end() ? -1 : it->second;",
			"\t}",
			"",
			"\tconst vector<int>& topo() {",
			"\t\tauto& v = _topo;",
			"\t\tif (!v.size()) {",
			"\t\t\tv.resize(b.size());",
			"\t\t\tiota(begin(v), end(v), 0);",
			"\t\t\tsort(begin(v), end(v), [&](int i, int j) { return b[i].len < b[j].len; });",
			"\t\t}",
			"\t\treturn v;",
			"\t}",
			"",
			"\ttemplate<class F, class G>",
			"\tauto dp_tree(F f, G g) {",
			"\t\tauto& t = topo();",
			"\t\tint n = b.size();",
			"\t\tvector<decltype(f(0))> v(n);",
			"\t\tfor (int i=0; i<n; i++)",
			"\t\t\tv[i] = f(i);",
			"\t\tfor (int i=n-1; i; i--) {",
			"\t\t\tint y = t[i], x = b[y].link;",
			"\t\t\tv[x] = g(v[x], v[y]);",
			"\t\t}",
			"\t\treturn v;",
			"\t}",
			"",
			"\tvector<int> firstpos() {",
			"\t\treturn dp_tree(",
			"\t\t\t[&](int i) { return b[i].cl ? numeric_limits<int>::max() : b[i].len; },",
			"\t\t\t[](int x, int y) { return min(x, y); });",
			"\t}",
			"",
			"\tvector<int> lastpos() {",
			"\t\treturn dp_tree(",
			"\t\t\t[&](int i) { return b[i].cl ? numeric_limits<int>::max() : b[i].len; },",
			"\t\t\t[](int x, int y) { return max(x, y); });",
			"\t}",
			"",
			"\tvector<int> endpos_size() {",
			"\t\treturn dp_tree([&](int i) { return 1 - b[i].cl; }, plus<int>());",
			"\t}",
			"};"
		]
	},

	"Substring comparator": {
		"scope": "cpp",
		"prefix": "substringcompare",
		"body": [
			"struct substring_compare {",
			"\tvector<vector<int>> cc;",
			"",
			"\tint re(int x, int n) { return x >= n ? x - n : x; }",
			"",
			"\tsubstring_compare(const string& s) {",
			"\t\tint n = s.size(), sz = 0;",
			"\t\tvector<int> c(begin(s), end(s)), p(n);",
			"\t\tvector<vector<int>> g(max(n, 128));",
			"\t\tfor (int i=0; i<n; i++) {",
			"\t\t\tg[c[i]].push_back(i);",
			"\t\t}",
			"\t\tfor (auto& gr : g) {",
			"\t\t\tfor (int i : gr) {",
			"\t\t\t\tp[sz++] = i;",
			"\t\t\t}",
			"\t\t\tgr.clear();",
			"\t\t}",
			"\t\tfor (int h=1; h<n; h*=2) {",
			"\t\t\tcc.push_back(c);",
			"\t\t\tvector<int> pn(n), cn(n);",
			"\t\t\tfor (int j : p) {",
			"\t\t\t\tint jp = re(j+n-h, n);",
			"\t\t\t\tg[c[jp]].push_back(jp);",
			"\t\t\t}",
			"\t\t\tsz = 0;",
			"\t\t\tfor (auto& gr : g) {",
			"\t\t\t\tfor (int i : gr) {",
			"\t\t\t\t\tpn[sz++] = i;",
			"\t\t\t\t}",
			"\t\t\t\tgr.clear();",
			"\t\t\t}",
			"\t\t\tcn[pn[0]] = 0;",
			"\t\t\tint nc = 1;",
			"\t\t\tfor (int i=1; i<n; i++) {",
			"\t\t\t\tint s0 = pn[i-1], s1 = pn[i];",
			"\t\t\t\tif (c[s1] == c[s0] && c[re(s1+h, n)] == c[re(s0+h, n)]) {",
			"\t\t\t\t\tcn[s1] = nc - 1;",
			"\t\t\t\t} else {",
			"\t\t\t\t\tcn[s1] = nc++;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tswap(c, cn);",
			"\t\t\tswap(p, pn);",
			"\t\t}",
			"\t}",
			"",
			"\tstruct substring {",
			"\t\tsubstring_compare* ctx;",
			"\t\tint l, r;",
			"",
			"\t\tint cmp(const substring& o) const {",
			"\t\t\tint tw = r - l, ow = o.r - o.l, tl = l, ol = o.l;",
			"\t\t\tint w = min(tw, ow);",
			"\t\t\tfor (size_t i=0; i<ctx->cc.size(); i++) {",
			"\t\t\t\tif (w & (1 << i)) {",
			"\t\t\t\t\tif (int d = ctx->cc[i][tl] - ctx->cc[i][ol]; d) {",
			"\t\t\t\t\t\treturn d; ",
			"\t\t\t\t\t}",
			"\t\t\t\t\ttl += 1 << i;",
			"\t\t\t\t\tol += 1 << i;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn tw - ow;",
			"\t\t}",
			"",
			"\t\tbool operator< (const substring& o) const {",
			"\t\t\treturn cmp(o) < 0;",
			"\t\t}",
			"",
			"\t\tbool operator== (const substring& o) const {",
			"\t\t\treturn cmp(o) == 0;",
			"\t\t}",
			"\t};",
			"",
			"\tsubstring operator() (int l, int r) {",
			"\t\treturn {this, l, r};",
			"\t}",
			"};"
		]
	},

	"Trie": {
		"scope": "cpp",
		"prefix": "trie",
		"body": [
			"template<class C = char, class T = int, class F = plus<T>>",
			"struct trie {",
			"\tstruct node : map<C, int> {",
			"\t\tT t, s;",
			"\t\tnode() : t(T()), s(T()) {}",
			"\t};",
			"",
			"\tvector<node> a;",
			"\tF f;",
			"\t",
			"\ttrie(F f = {}) : a(1), f(f) {}",
			"",
			"\ttemplate<class V>",
			"\tint add(const V& b, const T& t) {",
			"\t\tint x = 0;",
			"\t\tfor (C c : b) {",
			"\t\t\ta[x].s = f(a[x].s, t);",
			"\t\t\tint& p = a[x][c];",
			"\t\t\tif (!p) {",
			"\t\t\t\tx = p = a.size();",
			"\t\t\t\ta.emplace_back();",
			"\t\t\t} else {",
			"\t\t\t\tx = p;",
			"\t\t\t}",
			"\t\t}",
			"\t\ta[x].s = f(a[x].s, t);",
			"\t\ta[x].t = f(a[x].t, t);",
			"\t\treturn x;",
			"\t}",
			"",
			"\tint operator() (int x, const T& c) const {",
			"\t\tauto it = a[x].find(c);",
			"\t\treturn it == a[x].end() ? 0 : it->second;",
			"\t}",
			"",
			"\tconst node& operator[](int x) const {",
			"\t\treturn a[x];",
			"\t}",
			"};"
		]
	},

	"Z-Algorithm (Strings)": {
		"scope": "cpp",
		"prefix": "zalgorithm",
		"body": [
			"template<class V>",
			"vector<int> z_algorithm(const V& v) {",
			"\tint n = v.size();",
			"\tvector<int> z(n);",
			"\tfor (int i=1, l=0, r=0; i<n; i++) {",
			"\t\tif (i < r) z[i] = min(z[i-l], r-i);",
			"\t\twhile (i + z[i] < n && v[i + z[i]] == v[z[i]]) z[i]++;",
			"\t\tif (i + z[i] > r) l = i, r = i + z[i];",
			"\t}",
			"\treturn z;",
			"}"
		]
	},

	"Prefix function (KMP)": {
		"scope": "cpp",
		"prefix": "prefixfunction",
		"body": [
			"template<class V>",
			"vector<int> prefix_function(const V& v) {",
			"\tint n = v.size();",
			"\tvector<int> f(n+1);",
			"\tf[0] = -1;",
			"\tfor (int i=1; i<=n; i++) {",
			"\t\tint r = f[i-1];",
			"\t\twhile (r != -1 && v[r] != v[i-1]) r = f[r];",
			"\t\tf[i] = r+1;",
			"\t}",
			"\treturn f;",
			"}"
		]
	},

	"Duval's algorithm (Lyndon factorization)": {
		"scope": "cpp",
		"prefix": "lyndonfactorization",
		"body": [
			"template<class S, class F>",
			"void duval(const S& s, F f) {",
			"\tint n = s.size();",
			"\tfor (int l=0; l<n;) {",
			"\t\tint r = l, p = l + 1;",
			"\t\tfor (; r < n && s[r] <= s[p]; ++r, ++p) {",
			"\t\t\tif (s[r] < s[p]) r = l-1;",
			"\t\t}",
			"\t\twhile (l <= r) {",
			"\t\t\tf(l, l+p-r);",
			"\t\t\tl += p-r;",
			"\t\t}",
			"\t}",
			"}"
		]
	},

	"Lexicographically minimum rotation": {
		"scope": "cpp",
		"prefix": "minrotation",
		"body": [
			"template<class S>",
			"int min_rotation(S s) {",
			"\tint n = s.size();",
			"\ts.resize(2 * n);",
			"\tcopy_n(s.begin(), n, s.begin() + n);",
			"\tint z = 0;",
			"\tduval(s, [&](int l, int r) { if (l < n) z = l; });",
			"\treturn z;",
			"}"
		]
	},

	"Manacher's algorithm (palindromes)": {
		"scope": "cpp",
		"prefix": "manacher",
		"body": [
			"// g = 1: even length, g = 0: odd length ",
			"template<class S>",
			"vector<int> manacher(const S& s, int g) {",
			"\tint n = s.size();",
			"\tvector<int> z(n-g);",
			"\tfor (int i=0, l=0, r=-1; i<n-g; i++) {",
			"\t\tif (i+g <= r) z[i] = min({z[l+r-i-g], i-l, r-i-g});",
			"\t\twhile (i >= z[i] && i+z[i]+g < n && s[i-z[i]] == s[i+z[i]+g]) z[i]++;",
			"\t\tz[i]--;",
			"\t\tif (i+z[i]+g > r) l = i-z[i], r=i+z[i]+g;",
			"\t}",
			"\treturn z;",
			"}"
		]
	},

	"Rolling hash": {
		"scope": "cpp",
		"prefix": "rollinghash",
		"body": [
			"template<int mod>",
			"struct rolling_hash {",
			"\tusing T = modint<mod>;",
			"",
			"\tstatic inline T base;",
			"\tstatic inline vector<T> pws;",
			"",
			"\tstatic T pw(int x) {",
			"\t\tif (pws.empty()) {",
			"\t\t\tbase = chrono::high_resolution_clock::now().time_since_epoch().count();",
			"\t\t\tpws = {1};",
			"\t\t}",
			"",
			"\t\twhile (x >= (int)pws.size()) pws.push_back(pws.back() * base);",
			"\t\treturn pws[x];",
			"\t}",
			"",
			"\tint l;",
			"\tT h;",
			"",
			"\trolling_hash() : l(0), h(0) {}",
			"",
			"\ttemplate<class X>",
			"\trolling_hash(X x) : l(1), h(x) {}",
			"",
			"\trolling_hash(int&& l, T&& h) : l(l), h(h) {}",
			"",
			"\trolling_hash operator+ (const rolling_hash& b) const {",
			"\t\treturn {l + b.l, h * pw(b.l) + b.h};",
			"\t}",
			"",
			"\trolling_hash operator- (const rolling_hash& b) const {",
			"\t\treturn {l - b.l, h - pw(l - b.l) * b.h};",
			"\t}",
			"",
			"\tbool operator< (const rolling_hash& b) const { return h < b.h; };",
			"\tbool operator> (const rolling_hash& b) const { return h > b.h; };",
			"\tbool operator== (const rolling_hash& b) const { return h == b.h; };",
			"\tbool operator!= (const rolling_hash& b) const { return h != b.h; };",
			"\tbool operator<= (const rolling_hash& b) const { return h <= b.h; };",
			"\tbool operator>= (const rolling_hash& b) const { return h >= b.h; };",
			"};",
			"// Some primes: 1921500998 1922211060 1819854627 1849026543"
		]
	},

	"Double hash": {
		"scope": "cpp",
		"prefix": "doublehash",
		"body": [
			"template<int m1, int m2>",
			"struct double_hash {",
			"\trolling_hash<m1> h1;",
			"\trolling_hash<m2> h2;",
			"",
			"\ttemplate<class T>",
			"\tdouble_hash(T x) : h1(x), h2(x) {}",
			"",
			"\tdouble_hash() {}",
			"",
			"\tdouble_hash(rolling_hash<m1>&& h1, rolling_hash<m2>&& h2) : h1(h1), h2(h2) {}",
			"",
			"\tdouble_hash operator+ (const double_hash& b) const {",
			"\t\treturn {h1 + b.h1, h2 + b.h2};",
			"\t}",
			"",
			"\tdouble_hash operator- (const double_hash& b) const {",
			"\t\treturn {h1 - b.h1, h2 - b.h2};",
			"\t}",
			"",
			"\tbool operator< (const double_hash& b) const { return tie(h1, h2) < tie(b.h1, b.h2); };",
			"\tbool operator> (const double_hash& b) const { return tie(h1, h2) > tie(b.h1, b.h2); };",
			"\tbool operator== (const double_hash& b) const { return tie(h1, h2) == tie(b.h1, b.h2); };",
			"\tbool operator!= (const double_hash& b) const { return tie(h1, h2) != tie(b.h1, b.h2); };",
			"\tbool operator<= (const double_hash& b) const { return tie(h1, h2) <= tie(b.h1, b.h2); };",
			"\tbool operator>= (const double_hash& b) const { return tie(h1, h2) >= tie(b.h1, b.h2); };",
			"};",
			"",
			"using dhash = double_hash<1983933308, 1957926429>;"
		]
	}
}