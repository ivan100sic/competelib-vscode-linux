{
	"Variables with built-in I/O": {
		"scope": "cpp",
		"prefix": "iovar",
		"body": [
			"template<class T>",
			"struct in {",
			"\tT x;",
			"\tin () : x() { cin >> x; }",
			"\tin (const T& x) : x(x) {}",
			"\tin (T&& x) : x(x) {}",
			"\toperator T& () { return x; }",
			"\toperator const T& () const { return x; }",
			"};",
			"",
			"template<class T>",
			"struct out {",
			"\tT x;",
			"\tout () : x() {}",
			"\tout (const T& x) : x(x) {}",
			"\tout (T&& x) : x(x) {}",
			"\toperator T& () { return x; }",
			"\toperator const T& () const { return x; }",
			"\t~out() { cout << x << ' '; }",
			"};",
			"",
			"typedef in<int> iint;",
			"typedef out<int> oint;",
			"typedef in<ll> ill;",
			"typedef out<ll> oll;",
			"typedef in<string> istr;",
			"typedef out<string> ostr;",
			"typedef vector<int> vi;",
			"typedef vector<iint> ivi;",
			"typedef vector<oint> ovi;"
		]
	},

	"Python-like range": {
		"scope": "cpp",
		"prefix": "rrange",
		"body": [
			"template<class T>",
			"struct rr {",
			"\tstruct valit {",
			"\t\tT val;",
			"\t\tvalit(T x) : val(x) {}",
			"\t\tT operator* () const { return val; }",
			"\t\tT operator* () { return val; }",
			"\t\tvalit& operator++ () {",
			"\t\t\t++val;",
			"\t\t\treturn *this;",
			"\t\t}",
			"\t\tbool operator != (const valit& other) const {",
			"\t\t\treturn val != other.val;",
			"\t\t}",
			"\t};",
			"",
			"\tconst valit l, r;",
			"\trr(T x) : l(0), r(x) {}",
			"\trr(T x, T y) : l(x), r(y) {}",
			"",
			"\tvalit begin() { return l; }",
			"\tvalit end() { return r; }",
			"};"
		]
	},

	"Unique value compressor": {
		"scope": "cpp",
		"prefix": "compressor",
		"body": [
			"template<class T>",
			"struct compressor {",
			"\tvector<T*> v;",
			"\tT b;",
			"\tcompressor(T b = T()) : b(b) {}",
			"\tvoid operator+=(T& x) { v.push_back(&x); }",
			"\tint operator()() {",
			"\t\tif (v.empty()) return 0;",
			"\t\tsort(v.begin(), v.end(), [](T* x, T* y) { return *x < *y; });",
			"\t\t*v[0] = b;",
			"\t\tT w = b;",
			"\t\tint q = 1;",
			"\t\tfor (size_t i=1; i<v.size(); i++) {",
			"\t\t\tif (*v[i] != *v[i-1]) ++w, ++q;",
			"\t\t\t*v[i] = w;",
			"\t\t}",
			"\t\treturn q;",
			"\t}",
			"};"
		]
	},

	"Minimum accumulator": {
		"scope": "cpp",
		"prefix": "minval",
		"body": [
			"template<class T = int>",
			"struct minval {",
			"\tT x;",
			"\tminval(T x = numeric_limits<T>::max()) : x(x) {}",
			"\tT operator() () const { return x; }",
			"\tminval operator+ (const minval& b) const { return min(x, b.x); }",
			"};"
		]
	},

	"Maximum accumulator": {
		"scope": "cpp",
		"prefix": "maxval",
		"body": [
			"template<class T = int>",
			"struct maxval {",
			"\tT x;",
			"\tmaxval(T x = numeric_limits<T>::min()) : x(x) {}",
			"\tT operator() () const { return x; }",
			"\tmaxval operator+ (const maxval& b) const { return max(x, b.x); }",
			"};"
		]
	},

	"Bidirectional sum": {
		"scope": "cpp",
		"prefix": "bidirectionalsum",
		"body": [
			"template<class T, class F = plus<T>>",
			"struct bidirectional_sum {",
			"\tT f, b;",
			"\tbidirectional_sum(T x = T()) : f(x), b(x) {}",
			"\tbidirectional_sum(T&& f, T&& b) : f(f), b(b) {}",
			"\tbidirectional_sum operator+ (const bidirectional_sum& o) const {",
			"\t\treturn {F()(f, o.f), F()(o.b, b)};",
			"\t}",
			"};"
		]
	},

	"Bitmasks" : {
		"scope": "cpp",
		"prefix": "bitmasks",
		"body": [
			"struct bitmask {",
			"\tint m;",
			"",
			"\tbitmask(int m = 0) : m(m) {}",
			"\toperator int() const { return m; }",
			"\tint operator() () const { return m; }",
			"\tbitmask operator& (bitmask b) const { return m & b.m; }",
			"\tbitmask operator| (bitmask b) const { return m | b.m; }",
			"\tbitmask operator^ (bitmask b) const { return m ^ b.m; }",
			"\tbitmask& operator&= (bitmask b) { return *this = *this & b; }",
			"\tbitmask& operator|= (bitmask b) { return *this = *this | b; }",
			"\tbitmask& operator^= (bitmask b) { return *this = *this ^ b; }",
			"\tbitmask& set(int i) { m |= 1 << i; return *this; }",
			"\tbitmask& reset(int i) { m &= ~(1 << i); return *this; }",
			"\tbitmask& flip(int i) { m ^= 1 << i; return *this; }",
			"\tint operator[](int i) const { return 1 & (m >> i); }",
			"\tint popcnt() { return __builtin_popcount(m); }",
			"",
			"\tstruct iterator {",
			"\t\tint n, i, m, v;",
			"\t\tvoid mv() { while (i < n && v != ((m >> i) & 1)) i++; }",
			"\t\tint operator*() const { return i; }",
			"\t\tbool operator== (const iterator& b) const { return i == b.i; }",
			"\t\tbool operator!= (const iterator& b) const { return !(*this == b); }",
			"\t\titerator& operator++() { i++; mv(); return *this; }",
			"\t};",
			"",
			"\tstruct iterable {",
			"\t\tint n, m, v;",
			"\t\titerator begin() const { iterator i{n, 0, m, v}; i.mv(); return i; }",
			"\t\titerator end() const { iterator i{n, n, m, v}; i.mv(); return i; }",
			"\t};",
			"",
			"\titerable on(int n) const { return {n, m, 1}; }",
			"\titerable off(int n) const { return {n, m, 0}; }",
			"};",
			"",
			"struct mask_loop {",
			"\tint f, t;",
			"",
			"\t// size of mask, number of items to skip from start and end",
			"\tmask_loop(int n, int f = 0, int t = 0) : f(f), t((1 << n) - t) {",
			"\t\tt = max(t, f);",
			"\t}",
			"",
			"\tstruct iterator {",
			"\t\tint m;",
			"\t\tbitmask operator*() const { return m; }",
			"\t\tbool operator== (const iterator& b) const { return m == b.m; }",
			"\t\tbool operator!= (const iterator& b) const { return !(*this == b); }",
			"\t\titerator& operator++() { m++; return *this; }",
			"\t};",
			"",
			"\titerator begin() const { return {f}; }",
			"\titerator end() const { return {t}; }",
			"};",
			"",
			"struct submask_loop {",
			"\tint m;",
			"",
			"\tsubmask_loop(int m) : m(m) {}",
			"",
			"\tstruct iterator {",
			"\t\tint i, m;",
			"\t\tbitmask operator*() const { return m - i; }",
			"\t\tbool operator== (const iterator& b) const { return i == b.i; }",
			"\t\tbool operator!= (const iterator& b) const { return !(*this == b); }",
			"\t\titerator& operator++() { i = i ? (i-1) & m : -1; return *this; }",
			"\t};",
			"",
			"\titerator begin() const { return {m, m}; }",
			"\titerator end() const { return {-1, m}; }",
			"};"
		]
	}
}
