{
	"Bit lattice": {
		"scope": "cpp",
		"prefix": "bitlattice",
		"body": [
			"template<class T>",
			"struct bit_lattice {",
			"\tint N, n;",
			"\tvector<T> a;",
			"",
			"\tbit_lattice(const vector<T>& a) : N(a.size()), n(__builtin_ctz(N)), a(a) {}",
			"\tbit_lattice(int n) : N(1 << n), n(n), a(N) {}",
			"\tT& operator[] (int x) { return a[x]; }",
			"\tconst T& operator[] (int x) const { return a[x]; }",
			"",
			"\ttemplate<int Up, class F, class G>",
			"\tstatic void loop(int N, F f, G g) {",
			"\t\tfor (int i=1; i<N; i<<=1)",
			"\t\t\tfor (int j=(Up?0:N-1); j!=(Up?N:-1); j+=(Up?1:-1))",
			"\t\t\t\tif (j & i) f(g(j - i), g(j));",
			"\t}",
			"",
			"\ttemplate<int Up, class F>",
			"\tvoid loop(F f) {",
			"\t\tloop<Up>(N, f, [this](int x) -> T& { return a[x]; });",
			"\t}",
			"",
			"\tvoid mul(const bit_lattice& b) { for (int i=0; i<N; i++) a[i] *= b[i]; }",
			"\tvoid mul(T b) { for (int i=0; i<N; i++) a[i] *= b; }",
			"",
			"\tvoid sos() { loop<1>([](T& l, T& h) { h += l; }); }",
			"\tvoid sos_inv() { loop<0>([](T& l, T& h) { h -= l; }); }",
			"\tvoid sos_zero() { loop<1>([](T& l, T& h) { l += h; }); }",
			"\tvoid sos_zero_inv() { loop<0>([](T& l, T& h) { l -= h; }); }",
			"\tvoid fft2n() { loop<1>([](T& l, T& h) { T s = l + h, d = l - h; l = s; h = d; }); }",
			"",
			"\tvoid operator|= (bit_lattice b) { sos(); b.sos(); mul(b); sos_inv(); }",
			"\tvoid operator&= (bit_lattice b) { sos_zero(); b.sos_zero(); mul(b); sos_zero_inv(); }",
			"\tvoid operator^= (bit_lattice b) { fft2n(); b.fft2n(); mul(b); fft2n(); mul(T(1) / T(N)); }",
			"",
			"\t// Subset convolution",
			"\tvoid add_sc(T* a, T* b) const {",
			"\t\tfor (int i=0; i<=n; i++) a[i] += b[i]; ",
			"\t}",
			"",
			"\tvoid sub_sc(T* a, T* b) const {",
			"\t\tfor (int i=0; i<=n; i++) a[i] -= b[i]; ",
			"\t}",
			"",
			"\tvoid mul_sc(T* a, T* b) const {",
			"\t\tfor (int i=n; i>=0; i--) {",
			"\t\t\tT t = 0;",
			"\t\t\tfor (int j=0; j<=i; j++) t += a[j] * b[i-j];",
			"\t\t\ta[i] = t;",
			"\t\t}",
			"\t}",
			"",
			"\tvector<T> sos_sc() const {",
			"\t\tvector<T> b(N*(n+1));",
			"\t\tfor (int i=0; i<N; i++) b[i*(n+1)+__builtin_popcount(i)] = a[i];",
			"\t\tloop<1>(N, [this](T* a, T* b) { add_sc(b, a); }, [&, this](int i) { return b.data()+i*(n+1); });",
			"\t\treturn b;",
			"\t}",
			"",
			"\tvoid sos_inv_sc(vector<T>& b) const {",
			"\t\tloop<0>(N, [this](T* a, T* b) { sub_sc(b, a); }, [&, this](int i) { return b.data()+i*(n+1); });",
			"\t}",
			"",
			"\t[[nodiscard]] bit_lattice subset_conv(const bit_lattice& b) const {",
			"\t\tauto c = sos_sc();",
			"\t\tauto d = b.sos_sc();",
			"\t\tfor (int i=0; i<N*(n+1); i+=n+1) mul_sc(c.data()+i, d.data()+i);",
			"\t\tsos_inv_sc(c);",
			"\t\tbit_lattice e(n);",
			"\t\tfor (int i=0; i<N; i++) e[i] = c[i*(n+1) + __builtin_popcount(i)];",
			"\t\treturn e;",
			"\t}",
			"};"
		]
	}
}
