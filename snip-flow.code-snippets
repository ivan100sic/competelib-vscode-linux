{
	"Maximum flow (Dinic's algorithm)": {
		"scope": "cpp",
		"prefix": "maxflow",
		"body": [
			"template<class T = int>",
			"struct max_flow {",
			"\tstruct edge {",
			"\t\tint next, v;",
			"\t\tT cap, flow;",
			"\t};",
			"",
			"\tint s, t;",
			"\tvector<int> start, level, used, q;",
			"\tvector<edge> g;",
			"",
			"\tmax_flow(int n, int s, int t) : s(s), t(t), start(n, -1), level(n, -1), used(n, -1), q(n) {}",
			"",
			"\tvoid add_edge(int u, int v, T cap, T rev = T()) {",
			"\t\tg.push_back({start[u], v, cap, T()});",
			"\t\tstart[u] = g.size() - 1;",
			"\t\tg.push_back({start[v], u, rev, T()});",
			"\t\tstart[v] = g.size() - 1;",
			"\t}",
			"",
			"\tbool bfs(int s, int t) {",
			"\t\tsize_t qs = 0, qe = 1;",
			"\t\tfill(level.begin(), level.end(), -1);",
			"\t\tq[0] = s;",
			"\t\tlevel[s] = 0;",
			"\t\twhile (qs != qe) {",
			"\t\t\tint x = q[qs++];",
			"\t\t\tfor (int i = start[x]; i != -1; i = g[i].next) {",
			"\t\t\t\tif (g[i].flow < g[i].cap && level[g[i].v] == -1) {",
			"\t\t\t\t\tlevel[g[i].v] = level[x] + 1;",
			"\t\t\t\t\tq[qe++] = g[i].v;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn level[t] != -1;",
			"\t}",
			"",
			"\tT dfs(int x, int t, T f) {",
			"\t\tif (x == t)",
			"\t\t\treturn f;",
			"\t\tfor (int& i = used[x]; i != -1; i = g[i].next) {",
			"\t\t\tint v = g[i].v;",
			"\t\t\tif (level[v] == level[x] + 1 && g[i].flow < g[i].cap) {",
			"\t\t\t\tT z = dfs(v, t, min(f, g[i].cap - g[i].flow));",
			"\t\t\t\tif (z > 0) {",
			"\t\t\t\t\tg[i].flow += z;",
			"\t\t\t\t\tg[i^1].flow -= z;",
			"\t\t\t\t\treturn z;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn T();",
			"\t}",
			"",
			"\tT operator() () {",
			"\t\tT f = T();",
			"\t\twhile (bfs(s, t)) {",
			"\t\t\tused = start;",
			"\t\t\twhile (1) {",
			"\t\t\t\tT z = dfs(s, t, numeric_limits<T>::max());",
			"\t\t\t\tf += z;",
			"\t\t\t\tif (!z) break;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn f;",
			"\t}",
			"};"
		]
	},

	"Minimum cost maximum flow (SPFA)": {
		"scope": "cpp",
		"prefix": "mincostmaxflow",
		"body": [
			"template<class T = int>",
			"struct min_cost_max_flow {",
			"\tstatic constexpr T inf = numeric_limits<T>::max();",
			"",
			"\tstruct edge {",
			"\t\tint v, t;",
			"\t\tT c, w, f;",
			"\t};",
			"",
			"\tvector<vector<edge>> g;",
			"\tint n, s, t;",
			"\tT f, w;",
			"",
			"\tmin_cost_max_flow(int n, int s, int t) : g(n), n(n), s(s), t(t), f(T()), w(T()) {}",
			"",
			"\tvoid add_edge(int u, int v, T c, T w, T f = T()) {",
			"\t\tedge e1 = {v, (int)g[v].size(), c, w, f};",
			"\t\tedge e2 = {u, (int)g[u].size(), 0, -w, -f};",
			"\t\tg[u].push_back(e1);",
			"\t\tg[v].push_back(e2);",
			"\t}",
			"",
			"\tvoid step(T h = inf) {",
			"\t\tstring l(n, 0);",
			"\t\tvector<T> d(n, inf);",
			"\t\tvector<int> p(n), q(n), pe(n);",
			"\t\tint qs = 0, qe = 0;",
			"\t\tq[qe++] = s;",
			"\t\td[s] = T();",
			"\t\twhile (qs != qe) {",
			"\t\t\tint u = q[qs++];",
			"\t\t\tif (qs == n) qs = 0;",
			"\t\t\tl[u] = 2;",
			"\t\t\tfor (size_t i=0; i<g[u].size(); i++) {",
			"\t\t\t\tedge& e = g[u][i];",
			"\t\t\t\tint v = e.v;",
			"\t\t\t\tif (e.f < e.c && d[u] + e.w < d[v]) {",
			"\t\t\t\t\td[v] = d[u] + e.w;",
			"\t\t\t\t\tif (l[v] == 0) {",
			"\t\t\t\t\t\tq[qe++] = v;",
			"\t\t\t\t\t\tif (qe == n) qe = 0;",
			"\t\t\t\t\t} else if (l[v] == 2) {",
			"\t\t\t\t\t\tif (--qs == -1) {",
			"\t\t\t\t\t\t\tqs = n-1;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\tq[qs] = v;",
			"\t\t\t\t\t}",
			"\t\t\t\t\tl[v] = 1;",
			"\t\t\t\t\tp[v] = u;",
			"\t\t\t\t\tpe[v] = i;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (d[t] == inf) return;",
			"\t\tT a = h;",
			"\t\tint y = t;",
			"\t\twhile (y != s) {",
			"\t\t\tint x = p[y];",
			"\t\t\tint i = pe[y];",
			"\t\t\ta = min(a, g[x][i].c - g[x][i].f);",
			"\t\t\ty = x;",
			"\t\t}",
			"\t\ty = t;",
			"\t\twhile (y != s) {",
			"\t\t\tint x = p[y];",
			"\t\t\tint i = pe[y];",
			"\t\t\tint j = g[x][i].t;",
			"\t\t\tg[x][i].f += a;",
			"\t\t\tg[y][j].f -= a;",
			"\t\t\tw += g[x][i].w * a;",
			"\t\t\ty = x;",
			"\t\t}",
			"\t\tf += a;",
			"\t}",
			"",
			"\tvoid operator()(T l = inf) {",
			"\t\twhile (1) {",
			"\t\t\tT o = f;",
			"\t\t\tstep(l - f);",
			"\t\t\tif (o == f) return;",
			"\t\t}",
			"\t}",
			"};"
		]
	}
}
