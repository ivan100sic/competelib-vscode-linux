{
	"Implicit segment tree": {
		"scope": "cpp",
		"prefix": "implicitsegtree",
		"body": [
			"template<class W, class T = int, class F = plus<T>>",
			"struct implicit_segtree {",
			"\tstruct node { T v; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tstatic inline bool is_leaf(W l, W r) { return Wu(r)-l == 1; }",
			"\tnode dn() { return {e, ~0, ~0}; }",
			"\tint nn() { a.emplace_back(dn()); return a.size() - 1; }",
			"",
			"\tT e;",
			"\tF f;",
			"\tW rl, rr;",
			"\tvector<node> a;",
			"",
			"\timplicit_segtree(W rl, W rr, T e = T(), F f = F()) :",
			"\t\te(e), f(f), rl(rl), rr(rr), a(1, dn()) {}",
			"",
			"\ttemplate<class L>",
			"\tint _au(W p, const T& v, int x, W xl, W xr, L op) {",
			"\t\tif (!~x) x = nn();",
			"\t\tif (is_leaf(xl, xr)) {",
			"\t\t\top(a[x].v, v);",
			"\t\t} else {",
			"\t\t\tW xm = midpoint(xl, xr);",
			"\t\t\tbool o = p < xm;",
			"\t\t\tint t = _au(p, v, o ? a[x].l : a[x].r, o ? xl : xm, o ? xm : xr, op);",
			"\t\t\t(o ? a[x].l : a[x].r) = t;",
			"\t\t\ta[x].v = f(~a[x].l ? a[a[x].l].v : e, ~a[x].r ? a[a[x].r].v : e);",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"",
			"\tvoid add(W p, const T& v) {",
			"\t\t_au(p, v, 0, rl, rr, [&](T& x, const T& y) { x = f(x, y); });",
			"\t}",
			"",
			"\tvoid set(W p, const T& v) {",
			"\t\t_au(p, v, 0, rl, rr, [&](T& x, const T& y) { x = y; });",
			"\t}",
			"",
			"\tT get(W l, W r, int x, W xl, W xr) {",
			"\t\tif (!~x || r <= xl || xr <= l)",
			"\t\t\treturn e;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].v;",
			"\t\tW xm = midpoint(xl, xr);",
			"\t\treturn f(get(l, r, a[x].l, xl, xm), get(l, r, a[x].r, xm, xr));",
			"\t}",
			"",
			"\tT operator() (W l, W r) { return get(l, r, 0, rl, rr); }",
			"};"
		]
	},

	"Implicit segment tree with lazy updates": {
		"scope": "cpp",
		"prefix": "implicitsegtreelazy",
		"body": [
			"template<class T, class U, class F, class G, class H, class W>",
			"struct implicit_segtreelazy {",
			"\tstruct node { T v; U u; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tstatic inline bool is_leaf(W l, W r) { return Wu(r)-l == 1; }",
			"\tnode dn() { return {e, eu, ~0, ~0}; }",
			"\tint nn() { a.emplace_back(dn()); return a.size() - 1; }",
			"",
			"\tT e; U eu;",
			"\tF f; G g; H h;",
			"\tW rl, rr;",
			"\tvector<node> a;",
			"",
			"\t// Add two elements",
			"\t// Add two updaters",
			"\t// Add an element and an update",
			"\t// index range",
			"\t// Neutral element",
			"\t// Neutral update",
			"\timplicit_segtreelazy(F f, G g, H h, W rl, W rr, T e = T(), U eu = U()) :",
			"\t\te(e), eu(eu), f(f), g(g), h(h), rl(rl), rr(rr), a(1, dn()) {}",
			"",
			"\tvoid push(int x, bool leaf) {",
			"\t\ta[x].v = h(a[x].v, a[x].u);",
			"\t\tif (!leaf) {",
			"\t\t\tif (!~a[x].l) a[x].l = nn();",
			"\t\t\tif (!~a[x].r) a[x].r = nn();",
			"\t\t\ta[a[x].l].u = g(a[a[x].l].u, a[x].u);",
			"\t\t\ta[a[x].r].u = g(a[a[x].r].u, a[x].u);",
			"\t\t}",
			"\t\ta[x].u = eu;",
			"\t}",
			"",
			"\tint update(W l, W r, const U& u, int x, W xl, W xr) {",
			"\t\tif (r <= xl || xr <= l)",
			"\t\t\treturn push(x, is_leaf(xl, xr)), x;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].u = g(a[x].u, u), push(x, is_leaf(xl, xr)), x;",
			"\t\tpush(x, is_leaf(xl, xr));",
			"\t\tW xm = midpoint(xl, xr);",
			"\t\tint t;",
			"\t\tt = update(l, r, u, a[x].l, xl, xm), a[x].l = t;",
			"\t\tt = update(l, r, u, a[x].r, xm, xr), a[x].r = t;",
			"\t\treturn x;",
			"\t}",
			"",
			"\tT get(W l, W r, int x, W xl, W xr) {",
			"\t\tif (r <= xl || xr <= l)",
			"\t\t\treturn e;",
			"\t\tpush(x, is_leaf(xl, xr));",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].v;",
			"\t\tW xm = midpoint(xl, xr);",
			"\t\treturn f(get(l, r, a[x].l, xl, xm), get(l, r, a[x].r, xm, xr));",
			"\t}",
			"",
			"\tvoid update(W l, W r, const U& u) { update(l, r, u, 0, rl, rr); }",
			"\tT operator() (W l, W r) { return get(l, r, 0, rl, rr); }",
			"};"
		]
	},

	"Persistent segment tree": {
		"scope": "cpp",
		"prefix": "persistentsegtree",
		"body": [
			"template<class W, class T = int, class F = plus<T>>",
			"struct persistent_segtree {",
			"\tstruct node { T v; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tstatic inline bool is_leaf(W l, W r) { return Wu(r)-l == 1; }",
			"\tnode dn() { return {e, ~0, ~0}; }",
			"\tint cn(int x = 0) { a.emplace_back(a[x]); return a.size() - 1; }",
			"",
			"\tT e;",
			"\tF f;",
			"\tW rl, rr;",
			"\tvector<node> a;",
			"",
			"\tpersistent_segtree(W rl, W rr, T e = T(), F f = F()) :",
			"\t\te(e), f(f), rl(rl), rr(rr), a(1, dn()) {}",
			"",
			"\ttemplate<class L>",
			"\tint _au(W p, const T& v, int x, W xl, W xr, L op) {",
			"\t\tx = cn(~x ? x : 0);",
			"\t\tif (is_leaf(xl, xr)) {",
			"\t\t\top(a[x].v, v);",
			"\t\t\treturn x;",
			"\t\t} else {",
			"\t\t\tW xm = midpoint(xl, xr);",
			"\t\t\tbool o = p < xm;",
			"\t\t\tint t = _au(p, v, o ? a[x].l : a[x].r, o ? xl : xm, o ? xm : xr, op);",
			"\t\t\t(o ? a[x].l : a[x].r) = t;",
			"\t\t\ta[x].v = f(~a[x].l ? a[a[x].l].v : e, ~a[x].r ? a[a[x].r].v : e);",
			"\t\t\treturn x;",
			"\t\t}",
			"\t}",
			"",
			"\tint add(int x, W p, const T& v) {",
			"\t\treturn _au(p, v, x, rl, rr, [&](T& x, const T& y) { x = f(x, y); });",
			"\t}",
			"",
			"\tint update(int x, W p, const T& v) {",
			"\t\treturn _au(p, v, x, rl, rr, [&](T& x, const T& y) { x = y; });",
			"\t}",
			"",
			"\tT get(W l, W r, int x, W xl, W xr) {",
			"\t\tif (!~x || r <= xl || xr <= l)",
			"\t\t\treturn e;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].v;",
			"\t\tW xm = midpoint(xl, xr);",
			"\t\treturn f(get(l, r, a[x].l, xl, xm), get(l, r, a[x].r, xm, xr));",
			"\t}",
			"",
			"\tT operator() (int x, W l, W r) { return get(l, r, x, rl, rr); }",
			"};"
		]
	},

	"Implicit Li Chao tree": {
		"scope": "cpp",
		"prefix": "implicitlichao",
		"body": [
			"template<class W, class T, bool maximize = false>",
			"struct implicit_lichao {",
			"\tstruct line {",
			"\t\tT k, b;",
			"\t\tT operator() (W x) const { return k*x + b; }",
			"\t};",
			"",
			"\tstruct node { line v; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tnode dn() { return {{0, numeric_limits<T>::max()}, ~0, ~0}; }",
			"\tint nn() { a.emplace_back(dn()); return a.size() - 1; }",
			"",
			"\tW l, r;",
			"\tvector<node> a;",
			"\timplicit_lichao(W l, W r) : l(l), r(r), a(1, dn()) {}",
			"",
			"\tint add(line p, int x, W xl, W xr) {",
			"\t\tif (!~x) x = nn();",
			"\t\tif (a[x].v(xl) <= p(xl) && a[x].v(xr) <= p(xr))",
			"\t\t\treturn x;",
			"\t\tif (p(xl) <= a[x].v(xl) && p(xr) <= a[x].v(xr))",
			"\t\t\treturn a[x].v = p, x;",
			"\t\tif (p(xl) < a[x].v(xl))",
			"\t\t\tswap(p, a[x].v);",
			"\t\tint xm = midpoint(xl, xr);",
			"\t\ta[x].l = add(p, a[x].l, xl, xm);",
			"\t\ta[x].r = add(p, a[x].r, xm+1, xr);",
			"\t\treturn x;",
			"\t}",
			"",
			"\timplicit_lichao& operator+= (line p) {",
			"\t\tif (maximize)",
			"\t\t\tp.k = -p.k, p.b = -p.b;",
			"\t\tadd(p, 0, l, r);",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tT operator() (W t) const {",
			"\t\tT v = numeric_limits<T>::max();",
			"\t\tint x = 0;",
			"\t\tW xl = l, xr = r;",
			"\t\twhile (~x) {",
			"\t\t\tv = min(v, a[x].v(t));",
			"\t\t\tW xm = midpoint(xl, xr);",
			"\t\t\tif (t <= xm) {",
			"\t\t\t\tx = a[x].l;",
			"\t\t\t\txr = xm;",
			"\t\t\t} else {",
			"\t\t\t\tx = a[x].r;",
			"\t\t\t\txl = xm + 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn maximize ? -v : v;",
			"\t}",
			"};"
		]
	},

	"Persistent Li Chao tree": {
		"scope": "cpp",
		"prefix": "persistentlichao",
		"body": [
			"template<class W, class T, bool maximize = false>",
			"struct persistent_lichao {",
			"\tstruct line {",
			"\t\tT k, b;",
			"\t\tT operator() (W x) const { return k*x + b; }",
			"\t};",
			"",
			"\tstruct node { line v; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tnode dn() { return {{0, numeric_limits<T>::max()}, ~0, ~0}; }",
			"\tint cn(int x = 0) { a.emplace_back(a[x]); return a.size() - 1; }",
			"",
			"\tW l, r;",
			"\tvector<node> a;",
			"\tpersistent_lichao(W l, W r) : l(l), r(r), a(1, dn()) {}",
			"",
			"\tint add(line p, int x, W xl, W xr) {",
			"\t\tif (~x && a[x].v(xl) <= p(xl) && a[x].v(xr) <= p(xr))",
			"\t\t\treturn x;",
			"\t\tx = cn(~x ? x : 0);",
			"\t\tif (p(xl) <= a[x].v(xl) && p(xr) <= a[x].v(xr))",
			"\t\t\treturn a[x].v = p, x;",
			"\t\tif (p(xl) < a[x].v(xl))",
			"\t\t\tswap(p, a[x].v);",
			"\t\tint xm = midpoint(xl, xr);",
			"\t\ta[x].l = add(p, a[x].l, xl, xm);",
			"\t\ta[x].r = add(p, a[x].r, xm+1, xr);",
			"\t\treturn x;",
			"\t}",
			"",
			"\tint add(int x, line p) {",
			"\t\tif (maximize)",
			"\t\t\tp.k = -p.k, p.b = -p.b;",
			"\t\treturn add(p, x, l, r);",
			"\t}",
			"",
			"\tT operator() (int x, W t) const {",
			"\t\tT v = numeric_limits<T>::max();",
			"\t\tW xl = l, xr = r;",
			"\t\twhile (~x) {",
			"\t\t\tv = min(v, a[x].v(t));",
			"\t\t\tW xm = midpoint(xl, xr);",
			"\t\t\tif (t <= xm) {",
			"\t\t\t\tx = a[x].l;",
			"\t\t\t\txr = xm;",
			"\t\t\t} else {",
			"\t\t\t\tx = a[x].r;",
			"\t\t\t\txl = xm + 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn maximize ? -v : v;",
			"\t}",
			"};"
		]
	},

	"Link-cut tree (commutative)": {
		"scope": "cpp",
		"prefix": "linkcutcommutative",
		"body": [
			"template<class T = int, class F = plus<T>>",
			"struct link_cut_commutative {",
			"\t// Credits: https://codeforces.com/blog/entry/75885",
			"\t// 1-based",
			"",
			"\tstruct node {",
			"\t\tT v, s;",
			"\t\tint c[2] = {0, 0}, p = 0, q = 0;",
			"\t\tbool f = false;",
			"\t};",
			"",
			"\tvector<node> a;",
			"\tF f;",
			"",
			"\tlink_cut_commutative(int n, T e = T(), F f = F(), T v = T()) : a(n+1), f(f) {",
			"\t\tfor (int i=1; i<=n; i++) {",
			"\t\t\ta[i].v = a[i].s = v;",
			"\t\t}",
			"\t\ta[0].v = a[0].s = e;",
			"\t}",
			"",
			"\tint dir(int x, int y) { return a[x].c[1] == y; }",
			"",
			"\tvoid sch(int x, int d, int y) {",
			"\t\tif (x) a[x].c[d] = y, pull(x);",
			"\t\tif (y) a[y].p = x;",
			"\t}",
			"",
			"\tvoid pull(int x) {",
			"\t\tif (!x) return;",
			"\t\ta[x].s = f(a[a[x].c[0]].s, f(a[x].v, a[a[x].c[1]].s));",
			"\t}",
			"",
			"\tvoid push(int x) {",
			"\t\tif (!x || !a[x].f) return;",
			"\t\tint& l = a[x].c[0];",
			"\t\tint& r = a[x].c[1];",
			"\t\ta[l].f ^= 1;",
			"\t\ta[r].f ^= 1;",
			"\t\tswap(l, r);",
			"\t\ta[x].f = 0;",
			"\t}",
			"",
			"\tvoid rotate(int x, int d) {",
			"\t\tint y = a[x].p, z = a[y].p, w = a[x].c[d];",
			"\t\tswap(a[x].q, a[y].q);",
			"\t\tsch(y, !d, w);",
			"\t\tsch(x, d, y);",
			"\t\tsch(z, dir(z, y), x);",
			"\t}",
			"",
			"\tvoid splay(int x) {",
			"\t\tfor (push(x); a[x].p;) {",
			"\t\t\tint y = a[x].p, z = a[y].p;",
			"\t\t\tpush(z);",
			"\t\t\tpush(y);",
			"\t\t\tpush(x);",
			"\t\t\tint dx = dir(y, x), dy = dir(z, y);",
			"\t\t\tif (!z) {",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else if (dx == dy) {",
			"\t\t\t\trotate(y, !dx);",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else {",
			"\t\t\t\trotate(x, dy);",
			"\t\t\t\trotate(x, dx);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid make_root(int u) {",
			"\t\taccess(u);",
			"\t\tint l = a[u].c[0];",
			"\t\ta[l].f ^= 1;",
			"\t\tswap(a[l].p, a[l].q);",
			"\t\tsch(u, 0, 0);",
			"\t}",
			"",
			"\tvoid access(int w) {",
			"\t\tfor (int v=0, u=w; u; u=a[v=u].q) {",
			"\t\t\tsplay(u);",
			"\t\t\tsplay(v);",
			"\t\t\tint r = a[u].c[1];",
			"\t\t\ta[v].q = 0;",
			"\t\t\tswap(a[r].p, a[r].q);",
			"\t\t\tsch(u, 1, v);",
			"\t\t}",
			"\t\tsplay(w);",
			"\t}",
			"",
			"\tvoid link(int u, int v) {",
			"\t\tmake_root(v);",
			"\t\ta[v].q = u;",
			"\t}",
			"",
			"\tvoid cut(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(u);",
			"\t\tsplay(v);",
			"\t\ta[v].q = 0;",
			"\t}",
			"",
			"\tbool connected(int u, int v) {",
			"\t\tif (u == v) return true;",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\tsplay(u);",
			"\t\treturn a[v].p == u || a[a[v].p].p == u;",
			"\t}",
			"",
			"\tvoid update(int x, const T& v) {",
			"\t\tmake_root(x);",
			"\t\taccess(x);",
			"\t\ta[x].v = a[x].s = v;",
			"\t}",
			"",
			"\tT operator()(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\treturn a[v].s;",
			"\t}",
			"};"
		]
	},

	"Link-cut tree (non-commutative)": {
		"scope": "cpp",
		"prefix": "linkcutnoncommutative",
		"body": [
			"template<class T = string, class F = plus<T>>",
			"struct link_cut_noncommutative {",
			"\t// Credits: https://codeforces.com/blog/entry/75885",
			"\t// 1-based",
			"",
			"\tstruct node {",
			"\t\tT v, s, r;",
			"\t\tint c[2] = {0, 0}, p = 0, q = 0;",
			"\t\tbool f = false;",
			"\t};",
			"",
			"\tvector<node> a;",
			"\tF f;",
			"",
			"\tlink_cut_noncommutative(int n, T e = T(), F f = F(), T v = T()) : a(n+1), f(f) {",
			"\t\tfor (int i=1; i<=n; i++) {",
			"\t\t\ta[i].v = a[i].s = a[i].r = v;",
			"\t\t}",
			"\t\ta[0].v = a[0].s = a[0].r = e;",
			"\t}",
			"",
			"\tint dir(int x, int y) { return a[x].c[1] == y; }",
			"",
			"\tvoid sch(int x, int d, int y) {",
			"\t\tif (x) a[x].c[d] = y, pull(x);",
			"\t\tif (y) a[y].p = x;",
			"\t}",
			"",
			"\tconst T& rdval(int x, int d) {",
			"\t\treturn (a[x].f ^ d) ? a[x].r : a[x].s;",
			"\t}",
			"",
			"\tvoid pull(int x) {",
			"\t\tif (!x) return;",
			"\t\ta[x].s = f(rdval(a[x].c[0], 0), f(a[x].v, rdval(a[x].c[1], 0)));",
			"\t\ta[x].r = f(rdval(a[x].c[1], 1), f(a[x].v, rdval(a[x].c[0], 1)));",
			"\t}",
			"",
			"\tvoid push(int x) {",
			"\t\tif (!x || !a[x].f) return;",
			"\t\tswap(a[x].s, a[x].r);",
			"\t\tint& l = a[x].c[0];",
			"\t\tint& r = a[x].c[1];",
			"\t\ta[l].f ^= 1;",
			"\t\ta[r].f ^= 1;",
			"\t\tswap(l, r);",
			"\t\ta[x].f = 0;",
			"\t}",
			"",
			"\tvoid rotate(int x, int d) {",
			"\t\tint y = a[x].p, z = a[y].p, w = a[x].c[d];",
			"\t\tswap(a[x].q, a[y].q);",
			"\t\tsch(y, !d, w);",
			"\t\tsch(x, d, y);",
			"\t\tsch(z, dir(z, y), x);",
			"\t}",
			"",
			"\tvoid splay(int x) {",
			"\t\tfor (push(x); a[x].p;) {",
			"\t\t\tint y = a[x].p, z = a[y].p;",
			"\t\t\tpush(z);",
			"\t\t\tpush(y);",
			"\t\t\tpush(x);",
			"\t\t\tint dx = dir(y, x), dy = dir(z, y);",
			"\t\t\tif (!z) {",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else if (dx == dy) {",
			"\t\t\t\trotate(y, !dx);",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else {",
			"\t\t\t\trotate(x, dy);",
			"\t\t\t\trotate(x, dx);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid make_root(int u) {",
			"\t\taccess(u);",
			"\t\tint l = a[u].c[0];",
			"\t\ta[l].f ^= 1;",
			"\t\tswap(a[l].p, a[l].q);",
			"\t\tsch(u, 0, 0);",
			"\t}",
			"",
			"\tvoid access(int w) {",
			"\t\tfor (int v=0, u=w; u; u=a[v=u].q) {",
			"\t\t\tsplay(u);",
			"\t\t\tsplay(v);",
			"\t\t\tint r = a[u].c[1];",
			"\t\t\ta[v].q = 0;",
			"\t\t\tswap(a[r].p, a[r].q);",
			"\t\t\tsch(u, 1, v);",
			"\t\t}",
			"\t\tsplay(w);",
			"\t}",
			"",
			"\tvoid link(int u, int v) {",
			"\t\tmake_root(v);",
			"\t\ta[v].q = u;",
			"\t}",
			"",
			"\tvoid cut(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(u);",
			"\t\tsplay(v);",
			"\t\ta[v].q = 0;",
			"\t}",
			"",
			"\tbool connected(int u, int v) {",
			"\t\tif (u == v) return true;",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\tsplay(u);",
			"\t\treturn a[v].p == u || a[a[v].p].p == u;",
			"\t}",
			"",
			"\tvoid update(int x, const T& v) {",
			"\t\tmake_root(x);",
			"\t\taccess(x);",
			"\t\ta[x].v = a[x].s = v;",
			"\t}",
			"",
			"\tT operator()(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\treturn a[v].f ? a[v].r : a[v].s;",
			"\t}",
			"};"
		]
	},

	"Link-cut tree (subtree sum, Abelian groups)": {
		"scope": "cpp",
		"prefix": "linkcutsubtreesum",
		"body": [
			"template<class T = int, class F = plus<T>, class I = negate<T>>",
			"struct link_cut_subtree_abelian {",
			"\t// Credits: https://codeforces.com/blog/entry/75885",
			"\t// 1-based",
			"",
			"\tstruct node {",
			"\t\tT v, s, l;",
			"\t\tint c[2] = {0, 0}, p = 0, q = 0;",
			"\t\tbool f = false;",
			"\t};",
			"",
			"\tvector<node> a;",
			"\tF f;",
			"\tI i;",
			"",
			"\tlink_cut_subtree_abelian(int n, T e = T(), F f = F(), I i = I(), T v = T()) : a(n+1), f(f), i(i) {",
			"\t\tfor (int j=1; j<=n; j++) {",
			"\t\t\ta[j].v = a[j].s = v;",
			"\t\t\ta[j].l = e;",
			"\t\t}",
			"\t\ta[0].v = a[0].s = a[0].l = e;",
			"\t}",
			"",
			"\tint dir(int x, int y) { return a[x].c[1] == y; }",
			"",
			"\tvoid sch(int x, int d, int y) {",
			"\t\tif (x) a[x].c[d] = y, pull(x);",
			"\t\tif (y) a[y].p = x;",
			"\t}",
			"",
			"\tvoid pull(int x) {",
			"\t\tif (!x) return;",
			"\t\ta[x].s = f(a[a[x].c[0]].s, f(a[x].v, f(a[a[x].c[1]].s, a[x].l)));",
			"\t}",
			"",
			"\tvoid push(int x) {",
			"\t\tif (!x || !a[x].f) return;",
			"\t\tint& l = a[x].c[0];",
			"\t\tint& r = a[x].c[1];",
			"\t\ta[l].f ^= 1;",
			"\t\ta[r].f ^= 1;",
			"\t\tswap(l, r);",
			"\t\ta[x].f = 0;",
			"\t}",
			"",
			"\tvoid rotate(int x, int d) {",
			"\t\tint y = a[x].p, z = a[y].p, w = a[x].c[d];",
			"\t\tswap(a[x].q, a[y].q);",
			"\t\tsch(y, !d, w);",
			"\t\tsch(x, d, y);",
			"\t\tsch(z, dir(z, y), x);",
			"\t}",
			"",
			"\tvoid splay(int x) {",
			"\t\tfor (push(x); a[x].p;) {",
			"\t\t\tint y = a[x].p, z = a[y].p;",
			"\t\t\tpush(z);",
			"\t\t\tpush(y);",
			"\t\t\tpush(x);",
			"\t\t\tint dx = dir(y, x), dy = dir(z, y);",
			"\t\t\tif (!z) {",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else if (dx == dy) {",
			"\t\t\t\trotate(y, !dx);",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else {",
			"\t\t\t\trotate(x, dy);",
			"\t\t\t\trotate(x, dx);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid make_root(int u) {",
			"\t\taccess(u);",
			"\t\tint l = a[u].c[0];",
			"\t\ta[l].f ^= 1;",
			"\t\ta[u].l = f(a[u].l, a[l].s);",
			"\t\tswap(a[l].p, a[l].q);",
			"\t\tsch(u, 0, 0);",
			"\t}",
			"",
			"\tvoid access(int w) {",
			"\t\tfor (int v=0, u=w; u; u=a[v=u].q) {",
			"\t\t\tsplay(u);",
			"\t\t\tsplay(v);",
			"\t\t\tint r = a[u].c[1];",
			"\t\t\ta[u].l = f(a[u].l, a[r].s);",
			"\t\t\ta[u].l = f(a[u].l, i(a[v].s));",
			"\t\t\ta[v].q = 0;",
			"\t\t\tswap(a[r].p, a[r].q);",
			"\t\t\tsch(u, 1, v);",
			"\t\t}",
			"\t\tsplay(w);",
			"\t}",
			"",
			"\tvoid link(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(u);",
			"\t\tmake_root(v);",
			"\t\ta[v].q = u;",
			"\t\ta[u].l = f(a[u].l, a[v].s);",
			"\t\ta[u].s = f(a[u].s, a[v].s);",
			"\t}",
			"",
			"\tvoid cut(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(u);",
			"\t\tsplay(v);",
			"\t\ta[v].q = 0;",
			"\t\ta[u].l = f(a[u].l, i(a[v].s));",
			"\t\ta[u].s = f(a[u].s, i(a[v].s));",
			"\t}",
			"",
			"\tbool connected(int u, int v) {",
			"\t\tif (u == v) return true;",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\tsplay(u);",
			"\t\treturn a[v].p == u || a[a[v].p].p == u;",
			"\t}",
			"",
			"\tvoid update(int x, const T& v) {",
			"\t\tadd(x, f(v, i(a[x].v)));",
			"\t}",
			"",
			"\tvoid add(int x, const T& v) {",
			"\t\tmake_root(x);",
			"\t\taccess(x);",
			"\t\ta[x].v = f(a[x].v, v);",
			"\t\ta[x].s = f(a[x].s, v);",
			"\t}",
			"",
			"\tT operator()(int v, int p) {",
			"\t\tmake_root(p);",
			"\t\taccess(p);",
			"\t\tsplay(v);",
			"\t\treturn a[v].s;",
			"\t}",
			"};"
		]
	}
}
