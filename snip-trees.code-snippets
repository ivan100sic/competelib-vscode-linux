{
	"Tree DP": {
		"scope": "cpp",
		"prefix": "treedp",
		"body": [
			"template<class T, class D, class E, class G, class U, class F = plus<D>>",
			"struct tree_dp {",
			"\tvector<T> a;",
			"\tD e;",
			"\tvector<D> up, dn, rt;",
			"\tF f;",
			"\tG g;",
			"\tU u;",
			"\tvector<pair<int, E>*> p;",
			"\tvector<vector<pair<int, E>>> h;",
			"",
			"\t// a : vertex array - typed T",
			"\t// b : array of edges - typed E",
			"\t// g : (D, T) -> D - extends the sum of subtrees with the root vertex",
			"\t// u : (D, E) -> D - extends a subtree with an edge",
			"\t// e : neutral element of D",
			"\t// f : (D, D) -> D - adds together two (extended) subtrees",
			"\ttree_dp(const vector<T>& a, const vector<tuple<int, int, E>>& b, G g, U u, D e = D(), F f = F()) :",
			"\t\ta(a), e(e), up(a.size()), dn(a.size()), f(f), g(g), u(u), p(a.size()), h(a.size())",
			"\t{",
			"\t\tfor (auto [x, y, z] : b) {",
			"\t\t\th[x].emplace_back(y, z);",
			"\t\t\th[y].emplace_back(x, z);",
			"\t\t}",
			"\t\tdfs1(0, 0);",
			"\t\tdfs2(0);",
			"\t\trt.resize(a.size());",
			"\t\trt[0] = dn[0];",
			"\t\tfor (int x=1; x<(int)a.size(); x++) {",
			"\t\t\tD d = u(up[x], p[x]->second);",
			"\t\t\tfor (auto& hh : h[x]) {",
			"\t\t\t\tauto& [y, w] = hh;",
			"\t\t\t\tif (y != p[x]->first)",
			"\t\t\t\t\td = f(d, u(dn[y], w));",
			"\t\t\t}",
			"\t\t\trt[x] = g(d, a[x]);",
			"\t\t}",
			"\t}",
			"",
			"\tD operator() (int x) { return rt[x]; }",
			"",
			"\tvoid dfs1(int x, int o) {",
			"\t\tD d = e;",
			"\t\tfor (auto& hh : h[x]) {",
			"\t\t\tauto& [y, w] = hh;",
			"\t\t\tif (y == o) {",
			"\t\t\t\tp[x] = &hh;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tdfs1(y, x);",
			"\t\t\td = f(d, u(dn[y], w));",
			"\t\t}",
			"\t\tdn[x] = g(d, a[x]);",
			"\t}",
			"",
			"\tvoid dfs2(int x) {",
			"\t\tD d = x ? u(up[x], p[x]->second) : e, t = e;",
			"\t\tint m = h[x].size() - !!x;",
			"\t\tvector<D> pref(m, e);",
			"\t\tint i = 0;",
			"\t\tfor (auto& hh : h[x]) {",
			"\t\t\tauto& [y, w] = hh;",
			"\t\t\tif (p[x] && p[x]->first == y) continue;",
			"\t\t\tpref[i++] = t;",
			"\t\t\tt = f(t, u(dn[y], w));",
			"\t\t}",
			"\t\tfor (int j=(int)h[x].size()-1; j>=0; j--) {",
			"\t\t\tauto& hh = h[x][j];",
			"\t\t\tauto& [y, w] = hh;",
			"\t\t\tif (p[x] && p[x]->first == y) continue;",
			"\t\t\ti--;",
			"\t\t\tup[y] = g(f(pref[i], d), a[x]);",
			"\t\t\td = f(d, u(dn[y], w));",
			"\t\t}",
			"\t\tfor (auto& hh : h[x]) {",
			"\t\t\tauto& [y, w] = hh;",
			"\t\t\tif (p[x] && p[x]->first == y) continue;",
			"\t\t\tdfs2(y);",
			"\t\t}",
			"\t}",
			"};"
		]
	},

	"Tree topology (basic, linear time)": {
		"scope": "cpp",
		"prefix": "treetopology",
		"body": [
			"struct tree_topology {",
			"\tint n;",
			"\tvector<int> p, d, l, r;",
			"\tvector<vector<int>> e;",
			"",
			"\tvoid dfs(int x, int& t) {",
			"\t\tl[x] = t++;",
			"\t\tfor (int y : e[x]) {",
			"\t\t\tif (y == p[x]) continue;",
			"\t\t\td[y] = d[x] + 1;",
			"\t\t\tp[y] = x;",
			"\t\t\tdfs(y, t);",
			"\t\t}",
			"\t\tr[x] = t;",
			"\t}",
			"",
			"\ttree_topology(const vector<pair<int, int>>& b) {",
			"\t\tn = b.size() + 1;",
			"\t\tp.resize(n);",
			"\t\te.resize(n);",
			"\t\td = l = r = p;",
			"\t\tfor (auto [x, y] : b) {",
			"\t\t\te[x].push_back(y);",
			"\t\t\te[y].push_back(x);",
			"\t\t}",
			"\t\tp[0] = -1;",
			"\t\tint t = 0;",
			"\t\tdfs(0, t);",
			"\t}",
			"",
			"\tbool above(int x, int y) {",
			"\t\treturn l[x] <= l[y] && r[y] <= r[x];",
			"\t}",
			"",
			"\tint size(int x) {",
			"\t\treturn r[x] - l[x];",
			"\t}",
			"};"
		]
	},

	"Tree topology (advanced, LCA, loglinear)": {
		"scope": "cpp",
		"prefix": "treetopologyex",
		"body": [
			"struct tree_topology_ex : tree_topology {",
			"\tint logd;",
			"\tvector<vector<int>> a;",
			"",
			"\ttree_topology_ex(const vector<pair<int, int>>& b, int logd) : tree_topology(b), logd(logd) {",
			"\t\ta.resize(logd);",
			"\t\ta[0] = p;",
			"\t\tfor (int i=1; i<logd; i++) {",
			"\t\t\ta[i].resize(n);",
			"\t\t\tfor (int j=0; j<n; j++) {",
			"\t\t\t\ta[i][j] = a[i-1][j] == -1 ? -1 : a[i-1][a[i-1][j]];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tint lift(int x, int k) {",
			"\t\tfor (int i=0; i<logd; i++) {",
			"\t\t\tif (x == -1) return -1;",
			"\t\t\tif (k & (1 << i)) x = a[i][x];",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"",
			"\tint lca(int x, int y) {",
			"\t\tif (d[x] > d[y]) swap(x, y);",
			"\t\ty = lift(y, d[y] - d[x]);",
			"\t\tif (x == y) return x;",
			"\t\tfor (int i=logd-1; i>=0; i--) {",
			"\t\t\tint u = a[i][x], v = a[i][y];",
			"\t\t\tif (u != v) x = u, y = v;",
			"\t\t}",
			"\t\treturn p[x];",
			"\t}",
			"",
			"\tint distance(int x, int y) {",
			"\t\tint z = lca(x, y);",
			"\t\treturn d[x] + d[y] - 2*d[z];",
			"\t}",
			"",
			"\tint kth(int x, int y, int k) {",
			"\t\tint z = lca(x, y);",
			"\t\tif (k <= d[x] - d[y]) {",
			"\t\t\treturn lift(x, k);",
			"\t\t} else {",
			"\t\t\treturn lift(y, d[x] + d[y] - 2*d[z] - k);",
			"\t\t}",
			"\t}",
			"};"
		]
	},

	"Centroid decomposition": {
		"scope": "cpp",
		"prefix": "centroiddecomposition",
		"body": [
			"struct centroid_decomposition {",
			"\tint n;",
			"\tvector<vector<int>> e;",
			"\tstring b;",
			"\tvector<int> s;",
			"",
			"\tcentroid_decomposition(const vector<pair<int, int>>& g) {",
			"\t\tint n = g.size() + 1;",
			"\t\te.resize(n);",
			"\t\ts.resize(n);",
			"\t\tb = string(n, 0);",
			"\t\tfor (auto [x, y] : g) {",
			"\t\t\te[x].push_back(y);",
			"\t\t\te[y].push_back(x);",
			"\t\t}",
			"\t\tsolve(0);",
			"\t}",
			"",
			"\tvoid dfs_size(int x, int p) {",
			"\t\ts[x] = 1;",
			"\t\tfor (int y : e[x]) {",
			"\t\t\tif (y == p || b[y]) continue;",
			"\t\t\tdfs_size(y, x);",
			"\t\t\ts[x] += s[y];",
			"\t\t}",
			"\t}",
			"",
			"\tvoid dfs_centroid(int x, int p, int w, int& c) {",
			"\t\tbool ok = 1;",
			"\t\tfor (int y : e[x]) {",
			"\t\t\tif (y == p || b[y]) continue;",
			"\t\t\tdfs_centroid(y, x, w, c);",
			"\t\t\tif (2*s[y] > w) ok = false;",
			"\t\t}",
			"\t\tif (x != p && 2*(w-s[x]) > w) ok = false;",
			"\t\tif (ok) c = x;",
			"\t}",
			"",
			"\tvoid solve(int x) {",
			"\t\tdfs_size(x, x);",
			"\t\tint c = x;",
			"\t\tdfs_centroid(x, x, s[x], c);",
			"\t\tb[c] = 1;",
			"\t\t// Prepare for dfs",
			"\t\tfor (int y : e[c]) {",
			"\t\t\tif (b[y]) continue;",
			"\t\t\t// Gather subtree info",
			"\t\t\tdfs(y, c);",
			"\t\t\t// Process info",
			"\t\t}",
			"",
			"\t\tfor (int y : e[c]) {",
			"\t\t\tif (!b[y]) solve(y);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid dfs(int x, int p) {",
			"\t\t// Enter node",
			"\t\tfor (int y : e[x]) {",
			"\t\t\tif (b[y] || y == p) continue;",
			"\t\t\t// Process and recurse",
			"\t\t\tdfs(y, x); ",
			"\t\t}",
			"\t}",
			"};"
		]
	}
}