{
	"Fenwick tree": {
		"scope": "cpp",
		"prefix": "fenwick",
		"body": [
			"template<class T = int, class F = plus<T>>",
			"struct fenwick {",
			"\tvector<T> a;",
			"\tT e;",
			"\tF f;",
			"",
			"\tfenwick(int n, T e = T(), F f = F()) : a(n, e), e(e), f(f) {}",
			"",
			"\tvoid add(int p, const T& v) {",
			"\t\tfor (p++; p <= (int)a.size(); p += p & -p)",
			"\t\t\ta[p-1] = f(a[p-1], v);",
			"\t}",
			"",
			"\tT operator() (int p) const {",
			"\t\tT v = e;",
			"\t\tfor (; p; p -= p & -p)",
			"\t\t\tv = f(v, a[p-1]);",
			"\t\treturn v;",
			"\t}",
			"};"
		]
	},

	"Segment tree": {
		"scope": "cpp",
		"prefix": "segtree",
		"body": [
			"template<class T = int, class F = plus<T>>",
			"struct segtree {",
			"\tint maxn;",
			"\tvector<T> a;",
			"\tT e;",
			"\tF f;",
			"",
			"\tsegtree(int n, T e = T(), F f = F(), T v = T()) : e(e), f(f) {",
			"\t\tmaxn = 1;",
			"\t\twhile (maxn < n)",
			"\t\t\tmaxn <<= 1;",
			"\t\ta.assign(2*maxn, v);",
			"\t\tfor (int i=maxn-1; i; i--)",
			"\t\t\ta[i] = f(a[2*i], a[2*i+1]);",
			"\t}",
			"",
			"\tvoid add(int p, const T& v) {",
			"\t\tp += maxn;",
			"\t\ta[p] = f(a[p], v);",
			"\t\tfor (p >>= 1; p; p >>= 1)",
			"\t\t\ta[p] = f(a[2*p], a[2*p+1]);",
			"\t}",
			"",
			"\tvoid set(int p, const T& v) {",
			"\t\tp += maxn;",
			"\t\ta[p] = v;",
			"\t\tfor (p >>= 1; p; p >>= 1)",
			"\t\t\ta[p] = f(a[2*p], a[2*p+1]);",
			"\t}",
			"",
			"\tT get(int l, int r, int x, int xl, int xr) const {",
			"\t\tif (r <= xl || xr <= l)",
			"\t\t\treturn e;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x];",
			"\t\tint xm = (xl+xr) >> 1;",
			"\t\treturn f(get(l, r, 2*x, xl, xm), get(l, r, 2*x+1, xm, xr));",
			"\t}",
			"",
			"\tT operator() (int l, int r) const {",
			"\t\treturn get(l, r, 1, 0, maxn);",
			"\t}",
			"};"
		]
	},

	"Segment tree with lazy updates": {
		"scope": "cpp",
		"prefix": "segtreelazy",
		"body": [
			"template<class T, class U, class F, class G, class H>",
			"struct segtreelazy {",
			"\tstruct node { T v; U u; };",
			"\tint maxn;",
			"\tvector<node> a;",
			"\tT e; U eu;",
			"\tF f; G g; H h;",
			"\t// Add two elements",
			"\t// Add two updaters",
			"\t// Add an element and an update",
			"\t// Neutral element",
			"\t// Neutral update",
			"\t// Bottom level element",
			"\tsegtreelazy(int n, F f, G g, H h, T e = T(), U eu = U(), T v = T()) :",
			"\t\te(e), eu(eu), f(f), g(g), h(h)",
			"\t{",
			"\t\tmaxn = 1;",
			"\t\twhile (maxn < n)",
			"\t\t\tmaxn <<= 1;",
			"\t\ta.assign(2*maxn, node{v, eu});",
			"\t\tfor (int i=maxn-1; i; i--)",
			"\t\t\ta[i].v = f(a[2*i].v, a[2*i+1].v);",
			"\t}",
			"",
			"\tvoid push(int x) {",
			"\t\ta[x].v = h(a[x].v, a[x].u);",
			"\t\tif (x < maxn) {",
			"\t\t\ta[2*x  ].u = g(a[2*x  ].u, a[x].u);",
			"\t\t\ta[2*x+1].u = g(a[2*x+1].u, a[x].u);",
			"\t\t}",
			"\t\ta[x].u = eu;",
			"\t}",
			"",
			"\tvoid set(int p, const T& v) {",
			"\t\tint x = 1, xl = 0, xr = maxn;",
			"\t\twhile (xr-xl > 1) {",
			"\t\t\tpush(x);",
			"\t\t\tint xm = (xl+xr) >> 1;",
			"\t\t\t(p < xm ? xr : xl) = xm;",
			"\t\t\tx = 2*x + (p >= xm);",
			"\t\t}",
			"\t\ta[x] = {v, eu};",
			"\t\tdo {",
			"\t\t\tpush(x^1);",
			"\t\t\tx >>= 1;",
			"\t\t\ta[x].v = f(a[2*x].v, a[2*x+1].v);",
			"\t\t} while (x > 1);",
			"\t}",
			"",
			"\tvoid update(int l, int r, const U& u, int x, int xl, int xr) {",
			"\t\tif (r <= xl || xr <= l)",
			"\t\t\treturn push(x);",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].u = g(a[x].u, u), push(x);",
			"\t\tpush(x);",
			"\t\tint xm = (xl+xr) >> 1;",
			"\t\tupdate(l, r, u, 2*x  , xl, xm);",
			"\t\tupdate(l, r, u, 2*x+1, xm, xr);",
			"\t\ta[x].v = f(a[2*x].v, a[2*x+1].v);",
			"\t}",
			"",
			"\tT get(int l, int r, int x, int xl, int xr) {",
			"\t\tpush(x);",
			"\t\tif (r <= xl || xr <= l)",
			"\t\t\treturn e;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].v;",
			"\t\tint xm = (xl+xr) >> 1;",
			"\t\treturn f(get(l, r, 2*x, xl, xm), get(l, r, 2*x+1, xm, xr));",
			"\t}",
			"",
			"\tvoid update(int l, int r, const U& u) { update(l, r, u, 1, 0, maxn); }",
			"\tT operator() (int l, int r) { return get(l, r, 1, 0, maxn); }",
			"};"
		]
	},

	"Monotonic queue": {
		"scope": "cpp",
		"prefix": "monotonicqueue",
		"body": [
			"template<class T = int, class F = plus<T>>",
			"struct monotonic_queue {",
			"\tstruct node { T v, s; };",
			"\tvector<node> a, b;",
			"\tT e;",
			"\tF f;",
			"",
			"\tmonotonic_queue(T e = T(), F f = F()) : e(e), f(f) {}",
			"",
			"\tvoid push(vector<node>& a, const T& v) {",
			"\t\tif (a.size())",
			"\t\t\ta.push_back({v, f(a.back().s, v)});",
			"\t\telse",
			"\t\t\ta.push_back({v, v});",
			"\t}",
			"",
			"\tvoid rotate() {",
			"\t\twhile (a.size()) {",
			"\t\t\tpush(b, a.back().v);",
			"\t\t\ta.pop_back();",
			"\t\t}",
			"\t}",
			"",
			"\tmonotonic_queue& operator+= (const T& x) {",
			"\t\tpush(a, x);",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tT operator() () const {",
			"\t\tT x = e;",
			"\t\tif (a.size()) x = f(x, a.back().s);",
			"\t\tif (b.size()) x = f(x, b.back().s);",
			"\t\treturn x;",
			"\t}",
			"",
			"\tvoid pop() {",
			"\t\tif (!b.size())",
			"\t\t\trotate();",
			"\t\tb.pop_back();",
			"\t}",
			"};"
		]
	},

	"Sparse table": {
		"scope": "cpp",
		"prefix": "sparsetable",
		"body": [
			"template<class T = int, class F = plus<T>>",
			"struct sparse_table {",
			"\tvector<vector<T>> d;",
			"\tT e;",
			"\tF f;",
			"",
			"\tsparse_table(vector<T> a, T e = T(), F f = F()) : e(e), f(f) {",
			"\t\td.push_back(a);",
			"\t\tint n = a.size();",
			"\t\tfor (int h=1; h*2<=n; h<<=1) {",
			"\t\t\tint m = a.size() - h;",
			"\t\t\tvector<T> b(m);",
			"\t\t\tfor (int i=0; i<m; i++)",
			"\t\t\t\tb[i] = f(a[i], a[i+h]);",
			"\t\t\td.push_back(b);",
			"\t\t\tswap(a, b);",
			"\t\t}",
			"\t}",
			"",
			"\tT operator() (int l, int r) const {",
			"\t\tif (l >= r) return e;",
			"\t\tint i = 31 - __builtin_clz(r-l);",
			"\t\treturn f(d[i][l], d[i][r-(1<<i)]);",
			"\t}",
			"};"
		]
	},

	"Fractional cascading": {
		"scope": "cpp",
		"prefix": "fractionalcascading",
		"body": [
			"template<class T = int>",
			"struct fractional_cascading {",
			"\tint maxn;",
			"\tvector<vector<T>> a;",
			"\tvector<vector<int>> pl, pr;",
			"",
			"\tfractional_cascading(const vector<vector<T>>& b) {",
			"\t\tint n = b.size();",
			"\t\tmaxn = 1;",
			"\t\twhile (maxn < n)",
			"\t\t\tmaxn <<= 1;",
			"\t\ta.resize(2*maxn);",
			"\t\tcopy(b.begin(), b.end(), a.begin() + maxn);",
			"\t\tbuild();",
			"\t}",
			"",
			"\tfractional_cascading(const vector<pair<int, T>>& b) {",
			"\t\tint n = 1;",
			"\t\tmaxn = 1;",
			"\t\tfor (const auto& [k, v] : b)",
			"\t\t\tn = max(n, k+1);",
			"\t\twhile (maxn < n)",
			"\t\t\tmaxn <<= 1;",
			"\t\ta.resize(2*maxn);",
			"\t\tfor (const auto& [k, v] : b)",
			"\t\t\ta[k + maxn].push_back(v);",
			"\t\tbuild();",
			"\t}",
			"",
			"\tvoid build() {",
			"\t\tpl.resize(maxn);",
			"\t\tpr.resize(maxn);",
			"\t\tfor (int i=0; i<maxn; i++)",
			"\t\t\tsort(begin(a[i+maxn]), end(a[i+maxn]));",
			"\t\tfor (int i=maxn-1; i; i--) {",
			"\t\t\tsize_t sl = 0, sr = 0, si = 0, q = a[2*i].size() + a[2*i+1].size();",
			"\t\t\tpl[i].resize(q+1);",
			"\t\t\tpr[i].resize(q+1);",
			"\t\t\ta[i].resize(q);",
			"\t\t\twhile (si < q) {",
			"\t\t\t\tint r;",
			"\t\t\t\tif (sr == a[2*i+1].size()) r = 0;",
			"\t\t\t\telse if (sl == a[2*i].size()) r = 1;",
			"\t\t\t\telse r = a[2*i+1][sr] < a[2*i][sl];",
			"\t\t\t\ta[i][si++] = a[2*i+r][(r ? sr : sl)++];",
			"\t\t\t\tpl[i][si] = sl;",
			"\t\t\t\tpr[i][si] = sr;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\ttemplate<class F>",
			"\tvoid get(int l, int r, F f, int x, int xl, int xr, int yl, int yr) const {",
			"\t\tif (r <= xl || xr <= l || yl == yr)",
			"\t\t\treturn;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn f(x, yl, yr);",
			"\t\tint xm = (xl+xr) >> 1;",
			"\t\tget(l, r, f, 2*x, xl, xm, pl[x][yl], pl[x][yr]);",
			"\t\tget(l, r, f, 2*x+1, xm, xr, pr[x][yl], pr[x][yr]);",
			"\t}",
			"",
			"\ttemplate<class F>",
			"\tvoid operator() (int l, int r, const T& lo, const T& hi, F f) const {",
			"\t\tint yl = lower_bound(begin(a[1]), end(a[1]), lo) - begin(a[1]);",
			"\t\tint yr = lower_bound(begin(a[1]), end(a[1]), hi) - begin(a[1]);",
			"\t\tget(l, r, f, 1, 0, maxn, yl, yr);",
			"\t}",
			"};"
		]
	},

	"Li Chao segment tree": {
		"scope": "cpp",
		"prefix": "lichao",
		"body": [
			"template<class T, bool maximize = false>",
			"struct lichao {",
			"\tstruct line {",
			"\t\tT k, b;",
			"\t\tT operator() (T x) const { return k*x + b; }",
			"\t};",
			"",
			"\tstatic inline int midpoint(int l, int r) { return l + ((r-l) >> 1); }",
			"\tint l;",
			"\tvector<line> a;",
			"",
			"\tlichao(int l, int r) : l(l) {",
			"\t\tint maxn = 1;",
			"\t\twhile (maxn < r-l)",
			"\t\t\tmaxn <<= 1;",
			"\t\ta.assign(2*maxn, line{0, numeric_limits<T>::max()});",
			"\t}",
			"",
			"\tvoid add(line p, int x, int xl, int xr) {",
			"\t\tif (a[x](l+xl) <= p(l+xl) && a[x](l+xr) <= p(l+xr))",
			"\t\t\treturn;",
			"\t\tif (p(l+xl) <= a[x](l+xl) && p(l+xr) <= a[x](l+xr)) {",
			"\t\t\ta[x] = p;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tif (p(l+xl) < a[x](l+xl))",
			"\t\t\tswap(p, a[x]);",
			"\t\tint xm = midpoint(xl, xr);",
			"\t\tadd(p, 2*x  , xl  , xm);",
			"\t\tadd(p, 2*x+1, xm+1, xr);",
			"\t}",
			"",
			"\tlichao& operator+= (line p) {",
			"\t\tif (maximize)",
			"\t\t\tp.k = -p.k, p.b = -p.b;",
			"\t\tadd(p, 1, 0, (a.size()>>1)-1);",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tT operator() (int t) const {",
			"\t\tint x = t + (a.size() >> 1) - l;",
			"\t\tT v = a[0].b;",
			"\t\tfor (; x; x >>= 1)",
			"\t\t\tv = min(v, a[x](t));",
			"\t\treturn maximize ? -v : v;",
			"\t}",
			"};"
		]
	},

	"Union-find": {
		"scope": "cpp",
		"prefix": "unionfind",
		"body": [
			"struct union_find {",
			"\tvector<int> p;",
			"\tunion_find(int n) : p(n) { iota(begin(p), end(p), 0); }",
			"\tbool operator() (int x, int y) { return e(x) == e(y); }",
			"\tint e(int x) {",
			"\t\tif (p[x] == x) return x;",
			"\t\treturn p[x] = e(p[x]);",
			"\t}",
			"\tbool join(int x, int y) {",
			"\t\tx = e(x), y = e(y);",
			"\t\tif (x == y) return false;",
			"\t\tp[x] = y;",
			"\t\treturn true;",
			"\t}",
			"};"
		]
	},

	"Union-find with rollback": {
		"scope": "cpp",
		"prefix": "unionfindrollback",
		"body": [
			"struct union_find_rollback {",
			"\tstruct elem { int p, s; };",
			"\tvector<elem> a;",
			"\tvector<pair<int*, int>> u;",
			"",
			"\tint root(int x) {",
			"\t\twhile (x != a[x].p) x = a[x].p;",
			"\t\treturn x;",
			"\t}",
			"",
			"\tvoid flag() { u.emplace_back(nullptr, 0); }",
			"\tvoid mark(int& x) { u.emplace_back(&x, x); }",
			"",
			"\tunion_find_rollback(int n) : a(n) {",
			"\t\tfor (int i=0; i<n; i++) a[i] = {i, 1};",
			"\t}",
			"",
			"\tvoid join(int x, int y) {",
			"\t\tx = root(x); y = root(y);",
			"\t\tif (x == y) return;",
			"\t\tif (a[x].s > a[y].s) {",
			"\t\t\tswap(x, y);",
			"\t\t}",
			"\t\tmark(a[x].p); mark(a[y].s);",
			"\t\ta[x].p = y;",
			"\t\ta[y].s += a[x].s;",
			"\t}",
			"",
			"\tvoid rollback() {",
			"\t\twhile (1) {",
			"\t\t\tauto [p, v] = u.back(); u.pop_back();",
			"\t\t\tif (p) {",
			"\t\t\t\t*p = v;",
			"\t\t\t} else {",
			"\t\t\t\treturn;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"};"
		]
	}
}
