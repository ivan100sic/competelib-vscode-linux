{
	"Tree DP": {
		"scope": "cpp",
		"prefix": "treedp",
		"body": [
			"template<class T, class D, class E, class G, class U, class F = plus<D>>",
			"struct tree_dp {",
			"\tvector<T> a;",
			"\tD e;",
			"\tvector<D> up, dn, rt;",
			"\tF f;",
			"\tG g;",
			"\tU u;",
			"\tvector<pair<int, E>*> p;",
			"\tvector<vector<pair<int, E>>> h;",
			"",
			"\t// a : vertex array - typed T",
			"\t// b : array of edges - typed E",
			"\t// g : (D, T) -> D - extends the sum of subtrees with the root vertex",
			"\t// u : (D, E) -> D - extends a subtree with an edge",
			"\t// e : neutral element of D",
			"\t// f : (D, D) -> D - adds together two (extended) subtrees",
			"\ttree_dp(const vector<T>& a, const vector<tuple<int, int, E>>& b, G g, U u, D e = D(), F f = F()) :",
			"\t\ta(a), e(e), up(a.size()), dn(a.size()), f(f), g(g), u(u), p(a.size()), h(a.size())",
			"\t{",
			"\t\tfor (auto [x, y, z] : b) {",
			"\t\t\th[x].emplace_back(y, z);",
			"\t\t\th[y].emplace_back(x, z);",
			"\t\t}",
			"\t\tdfs1(0, 0);",
			"\t\tdfs2(0);",
			"\t\trt.resize(a.size());",
			"\t\trt[0] = dn[0];",
			"\t\tfor (int x=1; x<(int)a.size(); x++) {",
			"\t\t\tD d = u(up[x], p[x]->second);",
			"\t\t\tfor (auto& hh : h[x]) {",
			"\t\t\t\tauto& [y, w] = hh;",
			"\t\t\t\tif (y != p[x]->first)",
			"\t\t\t\t\td = f(d, u(dn[y], w));",
			"\t\t\t}",
			"\t\t\trt[x] = g(d, a[x]);",
			"\t\t}",
			"\t}",
			"",
			"\tD operator() (int x) { return rt[x]; }",
			"",
			"\tvoid dfs1(int x, int o) {",
			"\t\tD d = e;",
			"\t\tfor (auto& hh : h[x]) {",
			"\t\t\tauto& [y, w] = hh;",
			"\t\t\tif (y == o) {",
			"\t\t\t\tp[x] = &hh;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tdfs1(y, x);",
			"\t\t\td = f(d, u(dn[y], w));",
			"\t\t}",
			"\t\tdn[x] = g(d, a[x]);",
			"\t}",
			"",
			"\tvoid dfs2(int x) {",
			"\t\tD d = x ? u(up[x], p[x]->second) : e, t = e;",
			"\t\tint m = h[x].size() - !!x;",
			"\t\tvector<D> pref(m, e);",
			"\t\tint i = 0;",
			"\t\tfor (auto& hh : h[x]) {",
			"\t\t\tauto& [y, w] = hh;",
			"\t\t\tif (p[x] && p[x]->first == y) continue;",
			"\t\t\tpref[i++] = t;",
			"\t\t\tt = f(t, u(dn[y], w));",
			"\t\t}",
			"\t\tfor (int j=(int)h[x].size()-1; j>=0; j--) {",
			"\t\t\tauto& hh = h[x][j];",
			"\t\t\tauto& [y, w] = hh;",
			"\t\t\tif (p[x] && p[x]->first == y) continue;",
			"\t\t\ti--;",
			"\t\t\tup[y] = g(f(pref[i], d), a[x]);",
			"\t\t\td = f(d, u(dn[y], w));",
			"\t\t}",
			"\t\tfor (auto& hh : h[x]) {",
			"\t\t\tauto& [y, w] = hh;",
			"\t\t\tif (p[x] && p[x]->first == y) continue;",
			"\t\t\tdfs2(y);",
			"\t\t}",
			"\t}",
			"};"
		]
	}
}