{
	"Real valued polynomials": {
		"scope": "cpp",
		"prefix": "polyreal",
		"body": [
			"template<class T>",
			"struct poly_real {",
			"\ttypedef complex<T> C;",
			"",
			"\tstatic int bitrev(int x, int n) {",
			"\t\tint y = 0;",
			"\t\twhile (n--)",
			"\t\t\ty = (y << 1) | (x & 1), x >>= 1;",
			"\t\treturn y;",
			"\t}",
			"",
			"\tstatic int true_size(int n) {",
			"\t\tif (n == 1) return 1;",
			"\t\treturn 1 << (32 - __builtin_clz(n - 1));",
			"\t}",
			"",
			"\tstatic void fft(vector<C>& a, bool inv) {",
			"\t\tint n = a.size(), l = 31 - __builtin_clz(n);",
			"\t\tfor (int i=0; i<n; i++) {",
			"\t\t\tint j = bitrev(i, l);",
			"\t\t\tif (j < i)",
			"\t\t\t\tswap(a[i], a[j]);",
			"\t\t}",
			"",
			"\t\tstatic int ords = 0;",
			"\t\tstatic vector<vector<C>> wv;",
			"\t\tstatic constexpr T pi = acos(T(-1));",
			"",
			"\t\twhile (l > ords) {",
			"\t\t\tint m = 1 << ords;",
			"\t\t\tvector<C> v(m);",
			"\t\t\tfor (int i=0; i<m; i++)",
			"\t\t\t\tv[i] = exp(C(0, pi*i / m));",
			"\t\t\twv.emplace_back(move(v));",
			"\t\t\tords++;",
			"\t\t}",
			"",
			"\t\tfor (int h=1, e=0; h<n; h<<=1, e++) {",
			"\t\t\tfor (int i=0; i<n; i+=2*h) {",
			"\t\t\t\tfor (int j=i; j<i+h; j++) {",
			"\t\t\t\t\tC w = wv[e][j-i];",
			"\t\t\t\t\tw = inv ? conj(w) : w;",
			"\t\t\t\t\tC u = a[j], v = a[j+h] * w;",
			"\t\t\t\t\ta[j] = u + v;",
			"\t\t\t\t\ta[j+h] = u - v;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (inv) {",
			"\t\t\tC n1 = C(1) / C(n);",
			"\t\t\tfor (C& x : a)",
			"\t\t\t\tx *= n1;",
			"\t\t}",
			"\t}",
			"",
			"\tvector<T> a;",
			"",
			"\tpoly_real(int n = 0) : a(n) {}",
			"\tpoly_real(T x) : a(1, x) {}",
			"\tpoly_real(const vector<T>& a) : a(a) {}",
			"",
			"\tauto begin() const { return a.cbegin(); }",
			"\tauto begin() { return a.begin(); }",
			"\tauto size() const { return a.size(); }",
			"\tauto end() const { return a.cend(); }",
			"\tauto end() { return a.end(); }",
			"",
			"\tT& operator[] (size_t i) { return a[i]; }",
			"\tconst T& operator[] (size_t i) const { return a[i]; }",
			"",
			"\tvoid trim() {",
			"\t\twhile (a.size() && abs(a.back()) < 1e-12)",
			"\t\t\ta.pop_back();",
			"\t}",
			"",
			"\tpoly_real& operator+= (const poly_real& b) {",
			"\t\ta.resize(max(a.size(), b.size()));",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\ta[i] += b[i];",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tpoly_real& operator-= (const poly_real& b) {",
			"\t\ta.resize(max(a.size(), b.size()));",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\ta[i] -= b[i];",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tpoly_real operator+ (const poly_real& b) const {",
			"\t\tauto t = *this; return t += b;",
			"\t}",
			"",
			"\tpoly_real operator- (const poly_real& b) const {",
			"\t\tauto t = *this; return t -= b;",
			"\t}",
			"",
			"\tpoly_real fft_multiply (const poly_real& b) const {",
			"\t\tint u = a.size() + b.size() - 1, n = true_size(u);",
			"\t\tvector<C> e(n), f(n);",
			"\t\tfor (int i=0; i<(int)a.size(); i++)",
			"\t\t\te[i] = a[i];",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\tf[i] = b[i];",
			"\t\tfft(e, false);",
			"\t\tfft(f, false);",
			"\t\tfor (int i=0; i<n; i++)",
			"\t\t\te[i] *= f[i];",
			"\t\tfft(e, true);",
			"\t\tpoly_real c(u);",
			"\t\tfor (int i=0; i<u; i++)",
			"\t\t\tc[i] = e[i].real();",
			"\t\tc.trim();",
			"\t\treturn c;",
			"\t}",
			"",
			"\tpoly_real brute_multiply (const poly_real& b) const {",
			"\t\tint u = a.size() + b.size() - 1;",
			"\t\tpoly_real c(u);",
			"\t\tfor (int i=0; i<(int)a.size(); i++)",
			"\t\t\tfor (int j=0; j<(int)b.size(); j++)",
			"\t\t\t\tc[i+j] += a[i] * b[j];",
			"\t\tc.trim();",
			"\t\treturn c;",
			"\t}",
			"",
			"\tpoly_real operator* (const poly_real& b) const {",
			"\t\tif (!size() || !b.size())",
			"\t\t\treturn {};",
			"\t\tint u = a.size() + b.size() - 1, n = true_size(u);",
			"\t\tif (12ll * (31 - __builtin_clz(n)) * n < (ll)a.size() * (ll)b.size())",
			"\t\t\treturn fft_multiply(b);",
			"\t\telse",
			"\t\t\treturn brute_multiply(b);",
			"\t}",
			"",
			"\tpoly_real& operator*= (const poly_real& b) {",
			"\t\treturn *this = *this * b;",
			"\t}",
			"",
			"\t// @n - power of two",
			"\tpoly_real poly_inv(int n) const {",
			"\t\tpoly_real a = *this;",
			"\t\ta.a.resize(n);",
			"\t\tpoly_real rn(T(1) / a[0]);",
			"\t\tfor (int l=1; l<n; l<<=1) {",
			"\t\t\tpoly_real an(2*l);",
			"\t\t\tfor (int i=0; i<2*l; i++)",
			"\t\t\t\tan[i] = a[i];",
			"\t\t\tauto tmp = rn * rn * an;",
			"\t\t\t(rn += rn) -= tmp;",
			"\t\t\trn.a.resize(2*l);",
			"\t\t}",
			"\t\treturn rn;",
			"\t}",
			"",
			"\t// @n - power of two",
			"\tpoly_real poly_sqrt(int n) const {",
			"\t\tif (size() == 0 || this->a[0] < 0)",
			"\t\t\treturn {};",
			"\t\tpoly_real a = *this;",
			"\t\tT scale = T(1) / a[0];",
			"\t\ta.a.resize(n);",
			"\t\tfor (int i=0; i<n; i++)",
			"\t\t\ta[i] *= scale;",
			"\t\tpoly_real rn(T(1));",
			"\t\tfor (int l=1; l<n; l<<=1) {",
			"\t\t\tauto t = rn + rn;",
			"\t\t\tt = t.poly_inv(l);",
			"\t\t\tauto b = a - rn * rn;",
			"\t\t\tb.a.resize(n);",
			"\t\t\tb.a.erase(b.a.begin(), b.a.begin() + l);",
			"\t\t\tb.a.resize(l);",
			"\t\t\tt *= b;",
			"\t\t\trn.a.resize(2*l);",
			"\t\t\tfor (int i=0; i<l; i++)",
			"\t\t\t\trn[i+l] = t[i];",
			"\t\t}",
			"\t\tscale = T(1) / sqrt(scale);",
			"\t\tfor (T& x : rn)",
			"\t\t\tx *= scale;",
			"\t\treturn rn;",
			"\t}",
			"};"
		]
	},

	"Complex valued polynomials": {
		"scope": "cpp",
		"prefix": "polycomplex",
		"body": [
			"template<class T>",
			"struct poly_complex {",
			"\ttypedef complex<T> C;",
			"",
			"\tstatic int bitrev(int x, int n) {",
			"\t\tint y = 0;",
			"\t\twhile (n--)",
			"\t\t\ty = (y << 1) | (x & 1), x >>= 1;",
			"\t\treturn y;",
			"\t}",
			"",
			"\tstatic int true_size(int n) {",
			"\t\tif (n == 1) return 1;",
			"\t\treturn 1 << (32 - __builtin_clz(n - 1));",
			"\t}",
			"",
			"\tstatic void fft(vector<C>& a, bool inv) {",
			"\t\tint n = a.size(), l = 31 - __builtin_clz(n);",
			"\t\tfor (int i=0; i<n; i++) {",
			"\t\t\tint j = bitrev(i, l);",
			"\t\t\tif (j < i)",
			"\t\t\t\tswap(a[i], a[j]);",
			"\t\t}",
			"",
			"\t\tstatic int ords = 0;",
			"\t\tstatic vector<vector<C>> wv;",
			"\t\tstatic constexpr T pi = acos(T(-1));",
			"",
			"\t\twhile (l > ords) {",
			"\t\t\tint m = 1 << ords;",
			"\t\t\tvector<C> v(m);",
			"\t\t\tfor (int i=0; i<m; i++)",
			"\t\t\t\tv[i] = exp(C(0, pi*i / m));",
			"\t\t\twv.emplace_back(move(v));",
			"\t\t\tords++;",
			"\t\t}",
			"",
			"\t\tfor (int h=1, e=0; h<n; h<<=1, e++) {",
			"\t\t\tfor (int i=0; i<n; i+=2*h) {",
			"\t\t\t\tfor (int j=i; j<i+h; j++) {",
			"\t\t\t\t\tC w = wv[e][j-i];",
			"\t\t\t\t\tw = inv ? conj(w) : w;",
			"\t\t\t\t\tC u = a[j], v = a[j+h] * w;",
			"\t\t\t\t\ta[j] = u + v;",
			"\t\t\t\t\ta[j+h] = u - v;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (inv) {",
			"\t\t\tC n1 = C(1) / C(n);",
			"\t\t\tfor (C& x : a)",
			"\t\t\t\tx *= n1;",
			"\t\t}",
			"\t}",
			"",
			"\tvector<C> a;",
			"",
			"\tpoly_complex(int n = 0) : a(n) {}",
			"\tpoly_complex(C x) : a(1, x) {}",
			"\tpoly_complex(const vector<C>& a) : a(a) {}",
			"",
			"\tauto begin() const { return a.cbegin(); }",
			"\tauto begin() { return a.begin(); }",
			"\tauto size() const { return a.size(); }",
			"\tauto end() const { return a.cend(); }",
			"\tauto end() { return a.end(); }",
			"",
			"\tC& operator[] (size_t i) { return a[i]; }",
			"\tconst C& operator[] (size_t i) const { return a[i]; }",
			"",
			"\tvoid trim() {",
			"\t\twhile (a.size() && abs(a.back()) < 1e-12)",
			"\t\t\ta.pop_back();",
			"\t}",
			"",
			"\tpoly_complex& operator+= (const poly_complex& b) {",
			"\t\ta.resize(max(a.size(), b.size()));",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\ta[i] += b[i];",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tpoly_complex& operator-= (const poly_complex& b) {",
			"\t\ta.resize(max(a.size(), b.size()));",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\ta[i] -= b[i];",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tpoly_complex operator+ (const poly_complex& b) const {",
			"\t\tauto t = *this; return t += b;",
			"\t}",
			"",
			"\tpoly_complex operator- (const poly_complex& b) const {",
			"\t\tauto t = *this; return t -= b;",
			"\t}",
			"",
			"\tpoly_complex fft_multiply (const poly_complex& b) const {",
			"\t\tint u = a.size() + b.size() - 1, n = true_size(u);",
			"\t\tvector<C> e(n), f(n);",
			"\t\tfor (int i=0; i<(int)a.size(); i++)",
			"\t\t\te[i] = a[i];",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\tf[i] = b[i];",
			"\t\tfft(e, false);",
			"\t\tfft(f, false);",
			"\t\tfor (int i=0; i<n; i++)",
			"\t\t\te[i] *= f[i];",
			"\t\tfft(e, true);",
			"\t\tpoly_complex c;",
			"\t\tc.a = move(e);",
			"\t\tc.trim();",
			"\t\treturn c;",
			"\t}",
			"",
			"\tpoly_complex brute_multiply (const poly_complex& b) const {",
			"\t\tint u = a.size() + b.size() - 1;",
			"\t\tpoly_complex c(u);",
			"\t\tfor (int i=0; i<(int)a.size(); i++)",
			"\t\t\tfor (int j=0; j<(int)b.size(); j++)",
			"\t\t\t\tc[i+j] += a[i] * b[j];",
			"\t\tc.trim();",
			"\t\treturn c;",
			"\t}",
			"",
			"\tpoly_complex operator* (const poly_complex& b) const {",
			"\t\tif (!size() || !b.size())",
			"\t\t\treturn {};",
			"\t\tint u = a.size() + b.size() - 1, n = true_size(u);",
			"\t\tif (12ll * (31 - __builtin_clz(n)) * n < (ll)a.size() * (ll)b.size())",
			"\t\t\treturn fft_multiply(b);",
			"\t\telse",
			"\t\t\treturn brute_multiply(b);",
			"\t}",
			"",
			"\tpoly_complex& operator*= (const poly_complex& b) {",
			"\t\treturn *this = *this * b;",
			"\t}",
			"",
			"\t// @n - power of two",
			"\tpoly_complex poly_inv(int n) const {",
			"\t\tpoly_complex a = *this;",
			"\t\ta.a.resize(n);",
			"\t\tpoly_complex rn(C(1) / a[0]);",
			"\t\tfor (int l=1; l<n; l<<=1) {",
			"\t\t\tpoly_complex an(2*l);",
			"\t\t\tfor (int i=0; i<2*l; i++)",
			"\t\t\t\tan[i] = a[i];",
			"\t\t\tauto tmp = rn * rn * an;",
			"\t\t\t(rn += rn) -= tmp;",
			"\t\t\trn.a.resize(2*l);",
			"\t\t}",
			"\t\treturn rn;",
			"\t}",
			"",
			"\t// @n - power of two",
			"\tpoly_complex poly_sqrt(int n) const {",
			"\t\tif (size() == 0)",
			"\t\t\treturn {};",
			"\t\tpoly_complex a = *this;",
			"\t\tC scale = C(1) / a[0];",
			"\t\ta.a.resize(n);",
			"\t\tfor (int i=0; i<n; i++)",
			"\t\t\ta[i] *= scale;",
			"\t\tpoly_complex rn(C(1));",
			"\t\tfor (int l=1; l<n; l<<=1) {",
			"\t\t\tauto t = rn + rn;",
			"\t\t\tt = t.poly_inv(l);",
			"\t\t\tauto b = a - rn * rn;",
			"\t\t\tb.a.resize(n);",
			"\t\t\tb.a.erase(b.a.begin(), b.a.begin() + l);",
			"\t\t\tb.a.resize(l);",
			"\t\t\tt *= b;",
			"\t\t\trn.a.resize(2*l);",
			"\t\t\tfor (int i=0; i<l; i++)",
			"\t\t\t\trn[i+l] = t[i];",
			"\t\t}",
			"\t\tscale = C(1) / sqrt(scale);",
			"\t\tfor (C& x : rn)",
			"\t\t\tx *= scale;",
			"\t\treturn rn;",
			"\t}",
			"};"
		]
	},

	"Polynomials modulo an integer": {
		"scope": "cpp",
		"prefix": "polymint",
		"body": [
			"template<int mod>",
			"struct poly_mint {",
			"\ttypedef modint<mod> mint;",
			"",
			"\tstatic int bitrev(int x, int n) {",
			"\t\tint y = 0;",
			"\t\twhile (n--)",
			"\t\t\ty = (y << 1) | (x & 1), x >>= 1;",
			"\t\treturn y;",
			"\t}",
			"",
			"\tstatic int true_size(int n) {",
			"\t\tif (n == 1) return 1;",
			"\t\treturn 1 << (32 - __builtin_clz(n - 1));",
			"\t}",
			"",
			"\tstatic mint primitive_root() {",
			"\t\tstatic mint cached = 0;",
			"\t\tif (cached == 0) {",
			"\t\t\tfor (int x=1;; x++) {",
			"\t\t\t\tint ok = 1;",
			"\t\t\t\tfor (int y=2; y*y<mod-1; y++) {",
			"\t\t\t\t\tif ((mod-1) % y == 0 && (mint(x) ^ ((mod-1) / y)) == 1)",
			"\t\t\t\t\t\tok = 0;",
			"\t\t\t\t}",
			"\t\t\t\tif (ok) {",
			"\t\t\t\t\tcached = x;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn cached;",
			"\t}",
			"",
			"\tstatic void fft(vector<mint>& a, bool inv) {",
			"\t\tint n = a.size(), l = 31 - __builtin_clz(n);",
			"\t\tfor (int i=0; i<n; i++) {",
			"\t\t\tint j = bitrev(i, l);",
			"\t\t\tif (j < i)",
			"\t\t\t\tswap(a[i], a[j]);",
			"\t\t}",
			"",
			"\t\tstatic int ords = 0;",
			"\t\tstatic vector<vector<mint>> wv;",
			"\t\tstatic vector<vector<mint>> winv;",
			"",
			"\t\twhile (l > ords) {",
			"\t\t\tint m = 1 << ords;",
			"\t\t\tvector<mint> v(m);",
			"\t\t\tmint b = primitive_root() ^ ((mod-1) / (2 * m));",
			"\t\t\tv[0] = 1;",
			"\t\t\tfor (int i=1; i<m; i++)",
			"\t\t\t\tv[i] = v[i-1] * b;",
			"\t\t\twv.emplace_back(move(v));",
			"",
			"\t\t\tb = b.inv();",
			"\t\t\tv.resize(m);",
			"\t\t\tv[0] = 1;",
			"\t\t\tfor (int i=1; i<m; i++)",
			"\t\t\t\tv[i] = v[i-1] * b;",
			"\t\t\twinv.emplace_back(move(v));",
			"\t\t\tords++;",
			"\t\t}",
			"",
			"\t\tfor (int h=1, e=0; h<n; h<<=1, e++) {",
			"\t\t\tfor (int i=0; i<n; i+=2*h) {",
			"\t\t\t\tfor (int j=i; j<i+h; j++) {",
			"\t\t\t\t\tmint w = (inv ? winv : wv)[e][j-i];",
			"\t\t\t\t\tmint u = a[j], v = a[j+h] * w;",
			"\t\t\t\t\ta[j] = u + v;",
			"\t\t\t\t\ta[j+h] = u - v;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (inv) {",
			"\t\t\tmint n1 = mint(n).inv();;",
			"\t\t\tfor (mint& x : a)",
			"\t\t\t\tx *= n1;",
			"\t\t}",
			"\t}",
			"",
			"\tvector<mint> a;",
			"",
			"\tpoly_mint(int n = 0) : a(n) {}",
			"\tpoly_mint(mint x) : a(1, x) {}",
			"\tpoly_mint(const vector<mint>& a) : a(a) {}",
			"",
			"\tauto begin() const { return a.cbegin(); }",
			"\tauto begin() { return a.begin(); }",
			"\tauto size() const { return a.size(); }",
			"\tauto end() const { return a.cend(); }",
			"\tauto end() { return a.end(); }",
			"",
			"\tmint& operator[] (size_t i) { return a[i]; }",
			"\tconst mint& operator[] (size_t i) const { return a[i]; }",
			"",
			"\tvoid trim() {",
			"\t\twhile (a.size() && a.back() == 0)",
			"\t\t\ta.pop_back();",
			"\t}",
			"",
			"\tpoly_mint& operator+= (const poly_mint& b) {",
			"\t\ta.resize(max(a.size(), b.size()));",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\ta[i] += b[i];",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tpoly_mint& operator-= (const poly_mint& b) {",
			"\t\ta.resize(max(a.size(), b.size()));",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\ta[i] -= b[i];",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tpoly_mint operator+ (const poly_mint& b) const {",
			"\t\tauto t = *this; return t += b;",
			"\t}",
			"",
			"\tpoly_mint operator- (const poly_mint& b) const {",
			"\t\tauto t = *this; return t -= b;",
			"\t}",
			"",
			"\tpoly_mint fft_multiply (const poly_mint& b) const {",
			"\t\tint u = a.size() + b.size() - 1, n = true_size(u);",
			"\t\tvector<mint> e(n), f(n);",
			"\t\tfor (int i=0; i<(int)a.size(); i++)",
			"\t\t\te[i] = a[i];",
			"\t\tfor (int i=0; i<(int)b.size(); i++)",
			"\t\t\tf[i] = b[i];",
			"\t\tfft(e, false);",
			"\t\tfft(f, false);",
			"\t\tfor (int i=0; i<n; i++)",
			"\t\t\te[i] *= f[i];",
			"\t\tfft(e, true);",
			"\t\tpoly_mint c;",
			"\t\tc.a = move(e);",
			"\t\tc.trim();",
			"\t\treturn c;",
			"\t}",
			"",
			"\tpoly_mint brute_multiply (const poly_mint& b) const {",
			"\t\tint u = a.size() + b.size() - 1;",
			"\t\tpoly_mint c(u);",
			"\t\tfor (int i=0; i<(int)a.size(); i++)",
			"\t\t\tfor (int j=0; j<(int)b.size(); j++)",
			"\t\t\t\tc[i+j] += a[i] * b[j];",
			"\t\tc.trim();",
			"\t\treturn c;",
			"\t}",
			"",
			"\tpoly_mint operator* (const poly_mint& b) const {",
			"\t\tif (!size() || !b.size())",
			"\t\t\treturn {};",
			"\t\tint u = a.size() + b.size() - 1, n = true_size(u);",
			"\t\tif (12ll * (31 - __builtin_clz(n)) * n < (ll)a.size() * (ll)b.size())",
			"\t\t\treturn fft_multiply(b);",
			"\t\telse",
			"\t\t\treturn brute_multiply(b);",
			"\t}",
			"",
			"\tpoly_mint& operator*= (const poly_mint& b) {",
			"\t\treturn *this = *this * b;",
			"\t}",
			"",
			"\t// @n - power of two",
			"\tpoly_mint poly_inv(int n) const {",
			"\t\tpoly_mint a = *this;",
			"\t\ta.a.resize(n);",
			"\t\tpoly_mint rn(a[0].inv());",
			"\t\tfor (int l=1; l<n; l<<=1) {",
			"\t\t\tpoly_mint an(2*l);",
			"\t\t\tfor (int i=0; i<2*l; i++)",
			"\t\t\t\tan[i] = a[i];",
			"\t\t\tauto tmp = rn * rn * an;",
			"\t\t\t(rn += rn) -= tmp;",
			"\t\t\trn.a.resize(2*l);",
			"\t\t}",
			"\t\treturn rn;",
			"\t}",
			"",
			"\t// @n - power of two, a[0] = 1",
			"\tpoly_mint poly_sqrt(int n) const {",
			"\t\tif (size() == 0)",
			"\t\t\treturn {};",
			"\t\tpoly_mint a = *this;",
			"\t\ta.a.resize(n);",
			"\t\tpoly_mint rn(mint(1));",
			"\t\tfor (int l=1; l<n; l<<=1) {",
			"\t\t\tauto t = rn + rn;",
			"\t\t\tt = t.poly_inv(l);",
			"\t\t\tauto b = a - rn * rn;",
			"\t\t\tb.a.resize(n);",
			"\t\t\tb.a.erase(b.a.begin(), b.a.begin() + l);",
			"\t\t\tb.a.resize(l);",
			"\t\t\tt *= b;",
			"\t\t\trn.a.resize(2*l);",
			"\t\t\tfor (int i=0; i<l; i++)",
			"\t\t\t\trn[i+l] = t[i];",
			"\t\t}",
			"\t\treturn rn;",
			"\t}",
			"};"
		]
	}
}
