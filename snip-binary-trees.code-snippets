{
	"Implicit segment tree": {
		"scope": "cpp",
		"prefix": "implicitsegtree",
		"body": [
			"template<class W, class T = int, class F = plus<T>>",
			"struct implicit_segtree {",
			"\tstruct node { T v; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tstatic inline bool is_leaf(W l, W r) { return Wu(r)-l == 1; }",
			"\tnode dn() { return {e, ~0, ~0}; }",
			"\tint nn() { a.emplace_back(dn()); return a.size() - 1; }",
			"",
			"\tT e;",
			"\tF f;",
			"\tW rl, rr;",
			"\tvector<node> a;",
			"",
			"\timplicit_segtree(W rl, W rr, T e = T(), F f = F()) :",
			"\t\te(e), f(f), rl(rl), rr(rr), a(1, dn()) {}",
			"",
			"\ttemplate<class L>",
			"\tint _au(W p, const T& v, int x, W xl, W xr, L op) {",
			"\t\tif (!~x) x = nn();",
			"\t\tif (is_leaf(xl, xr)) {",
			"\t\t\top(a[x].v, v);",
			"\t\t} else {",
			"\t\t\tW xm = midpoint(xl, xr);",
			"\t\t\tbool o = p < xm;",
			"\t\t\tint t = _au(p, v, o ? a[x].l : a[x].r, o ? xl : xm, o ? xm : xr, op);",
			"\t\t\t(o ? a[x].l : a[x].r) = t;",
			"\t\t\ta[x].v = f(~a[x].l ? a[a[x].l].v : e, ~a[x].r ? a[a[x].r].v : e);",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"",
			"\tvoid add(W p, const T& v) {",
			"\t\t_au(p, v, 0, rl, rr, [&](T& x, const T& y) { x = f(x, y); });",
			"\t}",
			"",
			"\tvoid set(W p, const T& v) {",
			"\t\t_au(p, v, 0, rl, rr, [&](T& x, const T& y) { x = y; });",
			"\t}",
			"",
			"\tT get(W l, W r, int x, W xl, W xr) {",
			"\t\tif (!~x || r <= xl || xr <= l)",
			"\t\t\treturn e;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].v;",
			"\t\tW xm = midpoint(xl, xr);",
			"\t\treturn f(get(l, r, a[x].l, xl, xm), get(l, r, a[x].r, xm, xr));",
			"\t}",
			"",
			"\tT operator() (W l, W r) { return get(l, r, 0, rl, rr); }",
			"};"
		]
	},

	"Implicit segment tree with lazy updates": {
		"scope": "cpp",
		"prefix": "implicitsegtreelazy",
		"body": [
			"template<class T, class U, class F, class G, class H, class W>",
			"struct implicit_segtreelazy {",
			"\tstruct node { T v; U u; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tstatic inline bool is_leaf(W l, W r) { return Wu(r)-l == 1; }",
			"\tnode dn() { return {e, eu, ~0, ~0}; }",
			"\tint nn() { a.emplace_back(dn()); return a.size() - 1; }",
			"",
			"\tT e; U eu;",
			"\tF f; G g; H h;",
			"\tW rl, rr;",
			"\tvector<node> a;",
			"",
			"\t// Add two elements",
			"\t// Add two updaters",
			"\t// Add an element and an update",
			"\t// index range",
			"\t// Neutral element",
			"\t// Neutral update",
			"\timplicit_segtreelazy(F f, G g, H h, W rl, W rr, T e = T(), U eu = U()) :",
			"\t\te(e), eu(eu), f(f), g(g), h(h), rl(rl), rr(rr), a(1, dn()) {}",
			"",
			"\tvoid push(int x, bool leaf) {",
			"\t\ta[x].v = h(a[x].v, a[x].u);",
			"\t\tif (!leaf) {",
			"\t\t\tif (!~a[x].l) a[x].l = nn();",
			"\t\t\tif (!~a[x].r) a[x].r = nn();",
			"\t\t\ta[a[x].l].u = g(a[a[x].l].u, a[x].u);",
			"\t\t\ta[a[x].r].u = g(a[a[x].r].u, a[x].u);",
			"\t\t}",
			"\t\ta[x].u = eu;",
			"\t}",
			"",
			"\tint update(W l, W r, const U& u, int x, W xl, W xr) {",
			"\t\tif (r <= xl || xr <= l)",
			"\t\t\treturn push(x, is_leaf(xl, xr)), x;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].u = g(a[x].u, u), push(x, is_leaf(xl, xr)), x;",
			"\t\tpush(x, is_leaf(xl, xr));",
			"\t\tW xm = midpoint(xl, xr);",
			"\t\tint t;",
			"\t\tt = update(l, r, u, a[x].l, xl, xm), a[x].l = t;",
			"\t\tt = update(l, r, u, a[x].r, xm, xr), a[x].r = t;",
			"\t\treturn x;",
			"\t}",
			"",
			"\tT get(W l, W r, int x, W xl, W xr) {",
			"\t\tif (r <= xl || xr <= l)",
			"\t\t\treturn e;",
			"\t\tpush(x, is_leaf(xl, xr));",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].v;",
			"\t\tW xm = midpoint(xl, xr);",
			"\t\treturn f(get(l, r, a[x].l, xl, xm), get(l, r, a[x].r, xm, xr));",
			"\t}",
			"",
			"\tvoid update(W l, W r, const U& u) { update(l, r, u, 0, rl, rr); }",
			"\tT operator() (W l, W r) { return get(l, r, 0, rl, rr); }",
			"};"
		]
	},

	"Persistent segment tree": {
		"scope": "cpp",
		"prefix": "persistentsegtree",
		"body": [
			"template<class W, class T = int, class F = plus<T>>",
			"struct persistent_segtree {",
			"\tstruct node { T v; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tstatic inline bool is_leaf(W l, W r) { return Wu(r)-l == 1; }",
			"\tnode dn() { return {e, ~0, ~0}; }",
			"\tint cn(int x = 0) { a.emplace_back(a[x]); return a.size() - 1; }",
			"",
			"\tT e;",
			"\tF f;",
			"\tW rl, rr;",
			"\tvector<node> a;",
			"",
			"\tpersistent_segtree(W rl, W rr, T e = T(), F f = F()) :",
			"\t\te(e), f(f), rl(rl), rr(rr), a(1, dn()) {}",
			"",
			"\ttemplate<class L>",
			"\tint _au(W p, const T& v, int x, W xl, W xr, L op) {",
			"\t\tx = cn(~x ? x : 0);",
			"\t\tif (is_leaf(xl, xr)) {",
			"\t\t\top(a[x].v, v);",
			"\t\t\treturn x;",
			"\t\t} else {",
			"\t\t\tW xm = midpoint(xl, xr);",
			"\t\t\tbool o = p < xm;",
			"\t\t\tint t = _au(p, v, o ? a[x].l : a[x].r, o ? xl : xm, o ? xm : xr, op);",
			"\t\t\t(o ? a[x].l : a[x].r) = t;",
			"\t\t\ta[x].v = f(~a[x].l ? a[a[x].l].v : e, ~a[x].r ? a[a[x].r].v : e);",
			"\t\t\treturn x;",
			"\t\t}",
			"\t}",
			"",
			"\tint add(int x, W p, const T& v) {",
			"\t\treturn _au(p, v, x, rl, rr, [&](T& x, const T& y) { x = f(x, y); });",
			"\t}",
			"",
			"\tint update(int x, W p, const T& v) {",
			"\t\treturn _au(p, v, x, rl, rr, [&](T& x, const T& y) { x = y; });",
			"\t}",
			"",
			"\tT get(W l, W r, int x, W xl, W xr) {",
			"\t\tif (!~x || r <= xl || xr <= l)",
			"\t\t\treturn e;",
			"\t\tif (l <= xl && xr <= r)",
			"\t\t\treturn a[x].v;",
			"\t\tW xm = midpoint(xl, xr);",
			"\t\treturn f(get(l, r, a[x].l, xl, xm), get(l, r, a[x].r, xm, xr));",
			"\t}",
			"",
			"\tT operator() (int x, W l, W r) { return get(l, r, x, rl, rr); }",
			"};"
		]
	},

	"Implicit Li Chao tree": {
		"scope": "cpp",
		"prefix": "implicitlichao",
		"body": [
			"template<class W, class T, bool maximize = false>",
			"struct implicit_lichao {",
			"\tstruct line {",
			"\t\tT k, b;",
			"\t\tT operator() (W x) const { return k*x + b; }",
			"\t};",
			"",
			"\tstruct node { line v; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tnode dn() { return {{0, numeric_limits<T>::max()}, ~0, ~0}; }",
			"\tint nn() { a.emplace_back(dn()); return a.size() - 1; }",
			"",
			"\tW l, r;",
			"\tvector<node> a;",
			"\timplicit_lichao(W l, W r) : l(l), r(r), a(1, dn()) {}",
			"",
			"\tint add(line p, int x, W xl, W xr) {",
			"\t\tif (!~x) x = nn();",
			"\t\tif (a[x].v(xl) <= p(xl) && a[x].v(xr) <= p(xr))",
			"\t\t\treturn x;",
			"\t\tif (p(xl) <= a[x].v(xl) && p(xr) <= a[x].v(xr))",
			"\t\t\treturn a[x].v = p, x;",
			"\t\tif (p(xl) < a[x].v(xl))",
			"\t\t\tswap(p, a[x].v);",
			"\t\tint xm = midpoint(xl, xr);",
			"\t\ta[x].l = add(p, a[x].l, xl, xm);",
			"\t\ta[x].r = add(p, a[x].r, xm+1, xr);",
			"\t\treturn x;",
			"\t}",
			"",
			"\timplicit_lichao& operator+= (line p) {",
			"\t\tif (maximize)",
			"\t\t\tp.k = -p.k, p.b = -p.b;",
			"\t\tadd(p, 0, l, r);",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tT operator() (W t) const {",
			"\t\tT v = numeric_limits<T>::max();",
			"\t\tint x = 0;",
			"\t\tW xl = l, xr = r;",
			"\t\twhile (~x) {",
			"\t\t\tv = min(v, a[x].v(t));",
			"\t\t\tW xm = midpoint(xl, xr);",
			"\t\t\tif (t <= xm) {",
			"\t\t\t\tx = a[x].l;",
			"\t\t\t\txr = xm;",
			"\t\t\t} else {",
			"\t\t\t\tx = a[x].r;",
			"\t\t\t\txl = xm + 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn maximize ? -v : v;",
			"\t}",
			"};"
		]
	},

	"Persistent Li Chao tree": {
		"scope": "cpp",
		"prefix": "persistentlichao",
		"body": [
			"template<class W, class T, bool maximize = false>",
			"struct persistent_lichao {",
			"\tstruct line {",
			"\t\tT k, b;",
			"\t\tT operator() (W x) const { return k*x + b; }",
			"\t};",
			"",
			"\tstruct node { line v; int l; int r; };",
			"\ttypedef typename make_unsigned<W>::type Wu;",
			"\tstatic inline W midpoint(W l, W r) { return l + (W)((Wu(r)-l) >> 1); }",
			"\tnode dn() { return {{0, numeric_limits<T>::max()}, ~0, ~0}; }",
			"\tint cn(int x = 0) { a.emplace_back(a[x]); return a.size() - 1; }",
			"",
			"\tW l, r;",
			"\tvector<node> a;",
			"\tpersistent_lichao(W l, W r) : l(l), r(r), a(1, dn()) {}",
			"",
			"\tint add(line p, int x, W xl, W xr) {",
			"\t\tif (~x && a[x].v(xl) <= p(xl) && a[x].v(xr) <= p(xr))",
			"\t\t\treturn x;",
			"\t\tx = cn(~x ? x : 0);",
			"\t\tif (p(xl) <= a[x].v(xl) && p(xr) <= a[x].v(xr))",
			"\t\t\treturn a[x].v = p, x;",
			"\t\tif (p(xl) < a[x].v(xl))",
			"\t\t\tswap(p, a[x].v);",
			"\t\tint xm = midpoint(xl, xr);",
			"\t\ta[x].l = add(p, a[x].l, xl, xm);",
			"\t\ta[x].r = add(p, a[x].r, xm+1, xr);",
			"\t\treturn x;",
			"\t}",
			"",
			"\tint add(int x, line p) {",
			"\t\tif (maximize)",
			"\t\t\tp.k = -p.k, p.b = -p.b;",
			"\t\treturn add(p, x, l, r);",
			"\t}",
			"",
			"\tT operator() (int x, W t) const {",
			"\t\tT v = numeric_limits<T>::max();",
			"\t\tW xl = l, xr = r;",
			"\t\twhile (~x) {",
			"\t\t\tv = min(v, a[x].v(t));",
			"\t\t\tW xm = midpoint(xl, xr);",
			"\t\t\tif (t <= xm) {",
			"\t\t\t\tx = a[x].l;",
			"\t\t\t\txr = xm;",
			"\t\t\t} else {",
			"\t\t\t\tx = a[x].r;",
			"\t\t\t\txl = xm + 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn maximize ? -v : v;",
			"\t}",
			"};"
		]
	},

	"Link-cut tree (commutative)": {
		"scope": "cpp",
		"prefix": "linkcutcommutative",
		"body": [
			"template<class T = int, class F = plus<T>>",
			"struct link_cut_commutative {",
			"\t// Credits: https://codeforces.com/blog/entry/75885",
			"\t// 1-based",
			"",
			"\tstruct node {",
			"\t\tT v, s;",
			"\t\tint c[2] = {0, 0}, p = 0, q = 0;",
			"\t\tbool f = false;",
			"\t};",
			"",
			"\tvector<node> a;",
			"\tF f;",
			"",
			"\tlink_cut_commutative(int n, T e = T(), F f = F(), T v = T()) : a(n+1), f(f) {",
			"\t\tfor (int i=1; i<=n; i++) {",
			"\t\t\ta[i].v = a[i].s = v;",
			"\t\t}",
			"\t\ta[0].v = a[0].s = e;",
			"\t}",
			"",
			"\tint dir(int x, int y) { return a[x].c[1] == y; }",
			"",
			"\tvoid sch(int x, int d, int y) {",
			"\t\tif (x) a[x].c[d] = y, pull(x);",
			"\t\tif (y) a[y].p = x;",
			"\t}",
			"",
			"\tvoid pull(int x) {",
			"\t\tif (!x) return;",
			"\t\ta[x].s = f(a[a[x].c[0]].s, f(a[x].v, a[a[x].c[1]].s));",
			"\t}",
			"",
			"\tvoid push(int x) {",
			"\t\tif (!x || !a[x].f) return;",
			"\t\tint& l = a[x].c[0];",
			"\t\tint& r = a[x].c[1];",
			"\t\ta[l].f ^= 1;",
			"\t\ta[r].f ^= 1;",
			"\t\tswap(l, r);",
			"\t\ta[x].f = 0;",
			"\t}",
			"",
			"\tvoid rotate(int x, int d) {",
			"\t\tint y = a[x].p, z = a[y].p, w = a[x].c[d];",
			"\t\tswap(a[x].q, a[y].q);",
			"\t\tsch(y, !d, w);",
			"\t\tsch(x, d, y);",
			"\t\tsch(z, dir(z, y), x);",
			"\t}",
			"",
			"\tvoid splay(int x) {",
			"\t\tfor (push(x); a[x].p;) {",
			"\t\t\tint y = a[x].p, z = a[y].p;",
			"\t\t\tpush(z);",
			"\t\t\tpush(y);",
			"\t\t\tpush(x);",
			"\t\t\tint dx = dir(y, x), dy = dir(z, y);",
			"\t\t\tif (!z) {",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else if (dx == dy) {",
			"\t\t\t\trotate(y, !dx);",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else {",
			"\t\t\t\trotate(x, dy);",
			"\t\t\t\trotate(x, dx);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid make_root(int u) {",
			"\t\taccess(u);",
			"\t\tint l = a[u].c[0];",
			"\t\ta[l].f ^= 1;",
			"\t\tswap(a[l].p, a[l].q);",
			"\t\tsch(u, 0, 0);",
			"\t}",
			"",
			"\tvoid access(int w) {",
			"\t\tfor (int v=0, u=w; u; u=a[v=u].q) {",
			"\t\t\tsplay(u);",
			"\t\t\tsplay(v);",
			"\t\t\tint r = a[u].c[1];",
			"\t\t\ta[v].q = 0;",
			"\t\t\tswap(a[r].p, a[r].q);",
			"\t\t\tsch(u, 1, v);",
			"\t\t}",
			"\t\tsplay(w);",
			"\t}",
			"",
			"\tvoid link(int u, int v) {",
			"\t\tmake_root(v);",
			"\t\ta[v].q = u;",
			"\t}",
			"",
			"\tvoid cut(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(u);",
			"\t\tsplay(v);",
			"\t\ta[v].q = 0;",
			"\t}",
			"",
			"\tbool connected(int u, int v) {",
			"\t\tif (u == v) return true;",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\tsplay(u);",
			"\t\treturn a[v].p == u || a[a[v].p].p == u;",
			"\t}",
			"",
			"\tvoid update(int x, const T& v) {",
			"\t\tmake_root(x);",
			"\t\taccess(x);",
			"\t\ta[x].v = a[x].s = v;",
			"\t}",
			"",
			"\tT operator()(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\treturn a[v].s;",
			"\t}",
			"};"
		]
	},

	"Link-cut tree (non-commutative)": {
		"scope": "cpp",
		"prefix": "linkcutnoncommutative",
		"body": [
			"template<class T = string, class F = plus<T>>",
			"struct link_cut_noncommutative {",
			"\t// Credits: https://codeforces.com/blog/entry/75885",
			"\t// 1-based",
			"",
			"\tstruct node {",
			"\t\tT v, s, r;",
			"\t\tint c[2] = {0, 0}, p = 0, q = 0;",
			"\t\tbool f = false;",
			"\t};",
			"",
			"\tvector<node> a;",
			"\tF f;",
			"",
			"\tlink_cut_noncommutative(int n, T e = T(), F f = F(), T v = T()) : a(n+1), f(f) {",
			"\t\tfor (int i=1; i<=n; i++) {",
			"\t\t\ta[i].v = a[i].s = a[i].r = v;",
			"\t\t}",
			"\t\ta[0].v = a[0].s = a[0].r = e;",
			"\t}",
			"",
			"\tint dir(int x, int y) { return a[x].c[1] == y; }",
			"",
			"\tvoid sch(int x, int d, int y) {",
			"\t\tif (x) a[x].c[d] = y, pull(x);",
			"\t\tif (y) a[y].p = x;",
			"\t}",
			"",
			"\tconst T& rdval(int x, int d) {",
			"\t\treturn (a[x].f ^ d) ? a[x].r : a[x].s;",
			"\t}",
			"",
			"\tvoid pull(int x) {",
			"\t\tif (!x) return;",
			"\t\ta[x].s = f(rdval(a[x].c[0], 0), f(a[x].v, rdval(a[x].c[1], 0)));",
			"\t\ta[x].r = f(rdval(a[x].c[1], 1), f(a[x].v, rdval(a[x].c[0], 1)));",
			"\t}",
			"",
			"\tvoid push(int x) {",
			"\t\tif (!x || !a[x].f) return;",
			"\t\tswap(a[x].s, a[x].r);",
			"\t\tint& l = a[x].c[0];",
			"\t\tint& r = a[x].c[1];",
			"\t\ta[l].f ^= 1;",
			"\t\ta[r].f ^= 1;",
			"\t\tswap(l, r);",
			"\t\ta[x].f = 0;",
			"\t}",
			"",
			"\tvoid rotate(int x, int d) {",
			"\t\tint y = a[x].p, z = a[y].p, w = a[x].c[d];",
			"\t\tswap(a[x].q, a[y].q);",
			"\t\tsch(y, !d, w);",
			"\t\tsch(x, d, y);",
			"\t\tsch(z, dir(z, y), x);",
			"\t}",
			"",
			"\tvoid splay(int x) {",
			"\t\tfor (push(x); a[x].p;) {",
			"\t\t\tint y = a[x].p, z = a[y].p;",
			"\t\t\tpush(z);",
			"\t\t\tpush(y);",
			"\t\t\tpush(x);",
			"\t\t\tint dx = dir(y, x), dy = dir(z, y);",
			"\t\t\tif (!z) {",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else if (dx == dy) {",
			"\t\t\t\trotate(y, !dx);",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else {",
			"\t\t\t\trotate(x, dy);",
			"\t\t\t\trotate(x, dx);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid make_root(int u) {",
			"\t\taccess(u);",
			"\t\tint l = a[u].c[0];",
			"\t\ta[l].f ^= 1;",
			"\t\tswap(a[l].p, a[l].q);",
			"\t\tsch(u, 0, 0);",
			"\t}",
			"",
			"\tvoid access(int w) {",
			"\t\tfor (int v=0, u=w; u; u=a[v=u].q) {",
			"\t\t\tsplay(u);",
			"\t\t\tsplay(v);",
			"\t\t\tint r = a[u].c[1];",
			"\t\t\ta[v].q = 0;",
			"\t\t\tswap(a[r].p, a[r].q);",
			"\t\t\tsch(u, 1, v);",
			"\t\t}",
			"\t\tsplay(w);",
			"\t}",
			"",
			"\tvoid link(int u, int v) {",
			"\t\tmake_root(v);",
			"\t\ta[v].q = u;",
			"\t}",
			"",
			"\tvoid cut(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(u);",
			"\t\tsplay(v);",
			"\t\ta[v].q = 0;",
			"\t}",
			"",
			"\tbool connected(int u, int v) {",
			"\t\tif (u == v) return true;",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\tsplay(u);",
			"\t\treturn a[v].p == u || a[a[v].p].p == u;",
			"\t}",
			"",
			"\tvoid update(int x, const T& v) {",
			"\t\tmake_root(x);",
			"\t\taccess(x);",
			"\t\ta[x].v = a[x].s = v;",
			"\t}",
			"",
			"\tT operator()(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\treturn a[v].f ? a[v].r : a[v].s;",
			"\t}",
			"};"
		]
	},

	"Link-cut tree (subtree sum, Abelian groups)": {
		"scope": "cpp",
		"prefix": "linkcutsubtreesum",
		"body": [
			"template<class T = int, class F = plus<T>, class I = negate<T>>",
			"struct link_cut_subtree_abelian {",
			"\t// Credits: https://codeforces.com/blog/entry/75885",
			"\t// 1-based",
			"",
			"\tstruct node {",
			"\t\tT v, s, l;",
			"\t\tint c[2] = {0, 0}, p = 0, q = 0;",
			"\t\tbool f = false;",
			"\t};",
			"",
			"\tvector<node> a;",
			"\tF f;",
			"\tI i;",
			"",
			"\tlink_cut_subtree_abelian(int n, T e = T(), F f = F(), I i = I(), T v = T()) : a(n+1), f(f), i(i) {",
			"\t\tfor (int j=1; j<=n; j++) {",
			"\t\t\ta[j].v = a[j].s = v;",
			"\t\t\ta[j].l = e;",
			"\t\t}",
			"\t\ta[0].v = a[0].s = a[0].l = e;",
			"\t}",
			"",
			"\tint dir(int x, int y) { return a[x].c[1] == y; }",
			"",
			"\tvoid sch(int x, int d, int y) {",
			"\t\tif (x) a[x].c[d] = y, pull(x);",
			"\t\tif (y) a[y].p = x;",
			"\t}",
			"",
			"\tvoid pull(int x) {",
			"\t\tif (!x) return;",
			"\t\ta[x].s = f(a[a[x].c[0]].s, f(a[x].v, f(a[a[x].c[1]].s, a[x].l)));",
			"\t}",
			"",
			"\tvoid push(int x) {",
			"\t\tif (!x || !a[x].f) return;",
			"\t\tint& l = a[x].c[0];",
			"\t\tint& r = a[x].c[1];",
			"\t\ta[l].f ^= 1;",
			"\t\ta[r].f ^= 1;",
			"\t\tswap(l, r);",
			"\t\ta[x].f = 0;",
			"\t}",
			"",
			"\tvoid rotate(int x, int d) {",
			"\t\tint y = a[x].p, z = a[y].p, w = a[x].c[d];",
			"\t\tswap(a[x].q, a[y].q);",
			"\t\tsch(y, !d, w);",
			"\t\tsch(x, d, y);",
			"\t\tsch(z, dir(z, y), x);",
			"\t}",
			"",
			"\tvoid splay(int x) {",
			"\t\tfor (push(x); a[x].p;) {",
			"\t\t\tint y = a[x].p, z = a[y].p;",
			"\t\t\tpush(z);",
			"\t\t\tpush(y);",
			"\t\t\tpush(x);",
			"\t\t\tint dx = dir(y, x), dy = dir(z, y);",
			"\t\t\tif (!z) {",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else if (dx == dy) {",
			"\t\t\t\trotate(y, !dx);",
			"\t\t\t\trotate(x, !dx);",
			"\t\t\t} else {",
			"\t\t\t\trotate(x, dy);",
			"\t\t\t\trotate(x, dx);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid make_root(int u) {",
			"\t\taccess(u);",
			"\t\tint l = a[u].c[0];",
			"\t\ta[l].f ^= 1;",
			"\t\ta[u].l = f(a[u].l, a[l].s);",
			"\t\tswap(a[l].p, a[l].q);",
			"\t\tsch(u, 0, 0);",
			"\t}",
			"",
			"\tvoid access(int w) {",
			"\t\tfor (int v=0, u=w; u; u=a[v=u].q) {",
			"\t\t\tsplay(u);",
			"\t\t\tsplay(v);",
			"\t\t\tint r = a[u].c[1];",
			"\t\t\ta[u].l = f(a[u].l, a[r].s);",
			"\t\t\ta[u].l = f(a[u].l, i(a[v].s));",
			"\t\t\ta[v].q = 0;",
			"\t\t\tswap(a[r].p, a[r].q);",
			"\t\t\tsch(u, 1, v);",
			"\t\t}",
			"\t\tsplay(w);",
			"\t}",
			"",
			"\tvoid link(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(u);",
			"\t\tmake_root(v);",
			"\t\ta[v].q = u;",
			"\t\ta[u].l = f(a[u].l, a[v].s);",
			"\t\ta[u].s = f(a[u].s, a[v].s);",
			"\t}",
			"",
			"\tvoid cut(int u, int v) {",
			"\t\tmake_root(u);",
			"\t\taccess(u);",
			"\t\tsplay(v);",
			"\t\ta[v].q = 0;",
			"\t\ta[u].l = f(a[u].l, i(a[v].s));",
			"\t\ta[u].s = f(a[u].s, i(a[v].s));",
			"\t}",
			"",
			"\tbool connected(int u, int v) {",
			"\t\tif (u == v) return true;",
			"\t\tmake_root(u);",
			"\t\taccess(v);",
			"\t\tsplay(u);",
			"\t\treturn a[v].p == u || a[a[v].p].p == u;",
			"\t}",
			"",
			"\tvoid update(int x, const T& v) {",
			"\t\tadd(x, f(v, i(a[x].v)));",
			"\t}",
			"",
			"\tvoid add(int x, const T& v) {",
			"\t\tmake_root(x);",
			"\t\taccess(x);",
			"\t\ta[x].v = f(a[x].v, v);",
			"\t\ta[x].s = f(a[x].s, v);",
			"\t}",
			"",
			"\tT operator()(int v, int p) {",
			"\t\tmake_root(p);",
			"\t\taccess(p);",
			"\t\tsplay(v);",
			"\t\treturn a[v].s;",
			"\t}",
			"};"
		]
	},

	"Treap": {
		"scope": "cpp",
		"prefix": "treap",
		"body": [
			"template<class T>",
			"struct treap {",
			"\tstruct node : T {",
			"\t\tunsigned p;",
			"\t\tint l, r;",
			"\t\t",
			"\t\ttemplate<class... A>",
			"\t\tnode(A&&... a) : T(forward<A>(a)...) {}",
			"\t};",
			"",
			"\tranlux48 re;",
			"\tvector<node> b;",
			"",
			"\ttreap() : re(chrono::high_resolution_clock::now().time_since_epoch().count()) {}",
			"\t",
			"\ttemplate<class... A>",
			"\tint create(A&&... a) {",
			"\t\tb.emplace_back(forward<A...>(a)...);",
			"\t\tb.back().l = b.back().r = -1;",
			"\t\tb.back().p = re();",
			"\t\treturn b.size() - 1;",
			"\t}",
			"",
			"\tvoid enter(int x) {",
			"\t\tif (x != -1) b[x].enter(b, x);",
			"\t}",
			"",
			"\tvoid pull(int x) {",
			"\t\tb[x].pull(b, x);",
			"\t}",
			"",
			"\tint join(int x, int y) {",
			"\t\tenter(x); enter(y);",
			"\t\tif (x == -1) return y;",
			"\t\tif (y == -1) return x;",
			"\t\tif (b[x].p > b[y].p) {",
			"\t\t\tb[y].l = join(x, b[y].l);",
			"\t\t\tpull(y);",
			"\t\t\treturn y;",
			"\t\t} else {",
			"\t\t\tb[x].r = join(b[x].r, y);",
			"\t\t\tpull(x);",
			"\t\t\treturn x;",
			"\t\t}",
			"\t}",
			"",
			"\ttemplate<class S>",
			"\tpair<int, int> split(int x, S&& s) {",
			"\t\tenter(x);",
			"\t\tif (x == -1) return {-1, -1};",
			"\t\tif (s(b, x)) {",
			"\t\t\tauto [y, z] = split(b[x].r, s);",
			"\t\t\tb[x].r = y;",
			"\t\t\tpull(x);",
			"\t\t\treturn {x, z};",
			"\t\t} else {",
			"\t\t\tauto [y, z] = split(b[x].l, s);",
			"\t\t\tb[x].l = z;",
			"\t\t\tpull(x);",
			"\t\t\treturn {y, x};",
			"\t\t}",
			"\t}",
			"",
			"\ttemplate<class E>",
			"\tvoid enumerate(int x, E&& e) {",
			"\t\tif (x == -1) return;",
			"\t\tenter(x);",
			"\t\tenumerate(b[x].l, e);",
			"\t\te(b, x);",
			"\t\tenumerate(b[x].r, e);",
			"\t}",
			"",
			"\t// Splits using sl first, then sr on the right piece",
			"\ttemplate<class F, class SL, class SR>",
			"\tint run(int x, SL&& sl, SR&& sr, F&& f) {",
			"\t\tauto [p, q] = split(x, sl);",
			"\t\tauto [r, s] = split(q, sr);",
			"\t\tf(b, r);",
			"\t\treturn join(p, join(r, s));",
			"\t}",
			"",
			"\ttemplate<class S, class... A>",
			"\tint emplace(int x, S&& s, A&&... a) {",
			"\t\tint y = create(forward<A>(a)...);",
			"\t\tauto [p, q] = split(x, s);",
			"\t\treturn join(p, join(y, q));",
			"\t}",
			"};",
			"",
			"// Inherit to implement sum of subtree trait",
			"template<class T>",
			"struct treap_sum {",
			"\tT m_sum_root;",
			"\tT m_sum_total;",
			"",
			"\ttemplate<class N>",
			"\tvoid pull(vector<N>& a, int x) {",
			"\t\tm_sum_total = a[x].l == -1 ? a[x].m_sum_root : a[a[x].l].m_sum_total + a[x].m_sum_root;",
			"\t\tif (a[x].r != -1) m_sum_total = m_sum_total + a[a[x].r].m_sum_total;",
			"\t}",
			"",
			"\tstruct splitter {",
			"\t\tT s;",
			"",
			"\t\tsplitter(T s) : s(s) {}",
			"",
			"\t\ttemplate<class N>",
			"\t\tbool operator() (vector<N>& a, int x) {",
			"\t\t\tT w = a[x].l == -1 ? a[x].m_sum_root : a[a[x].l].m_sum_total + a[x].m_sum_root;",
			"\t\t\treturn s >= w ? (s -= w, true) : false;",
			"\t\t}",
			"\t};",
			"};",
			"",
			"// Inherit to implement simple data storage trait",
			"template<class T>",
			"struct treap_data {",
			"\tT m_data;",
			"};",
			"",
			"// Inherit to implement single-element lazy updates trait",
			"template<class T>",
			"struct treap_update {",
			"\tT m_update;",
			"",
			"\ttreap_update(T u = T()) : m_update(u) {}",
			"",
			"\ttemplate<class N>",
			"\tvoid enter(vector<N>& a, int x) {",
			"\t\tN& n = a[x];",
			"\t\tn.m_data = n.m_data + m_update;",
			"\t\tif (n.l != -1) a[n.l].m_update = a[n.l].m_update + n.m_update;",
			"\t\tif (n.r != -1) a[n.r].m_update = a[n.r].m_update + n.m_update;",
			"\t\tn.m_update = T();",
			"\t}",
			"};",
			"",
			"template<class T, class F = less<T>>",
			"struct treap_compare_splitter {",
			"\tT v; F f;",
			"\ttreap_compare_splitter(const T& v, F f = {}) : v(v), f(f) {}",
			"",
			"\ttemplate<class N>",
			"\tbool operator() (vector<N>& a, int x) {",
			"\t\treturn f(a[x].m_data, v);",
			"\t}",
			"};",
			"",
			"// Inherit to implement reverse trait",
			"struct treap_reverser {",
			"\tbool m_reversed;",
			"",
			"\ttemplate<class N>",
			"\tvoid enter(vector<N>& a, int x) {",
			"\t\tN& n = a[x];",
			"\t\tif (n.m_reversed) {",
			"\t\t\tswap(n.l, n.r);",
			"\t\t\tif (n.l != -1) a[n.l].m_reversed ^= 1;",
			"\t\t\tif (n.r != -1) a[n.r].m_reversed ^= 1;",
			"\t\t}",
			"\t\tn.m_reversed = false;",
			"\t}",
			"",
			"\tstruct runner {",
			"\t\ttemplate<class N>",
			"\t\tvoid operator() (vector<N>& a, int x) {",
			"\t\t\tif (x != -1) a[x].m_reversed ^= 1;",
			"\t\t}",
			"\t};",
			"};",
			"",
			"// Inherit to implement size trait",
			"struct treap_size {",
			"\tint m_size;",
			"",
			"\ttreap_size() : m_size(1) {}",
			"",
			"\ttemplate<class N>",
			"\tvoid pull(vector<N>& a, int x) {",
			"\t\tm_size = 1;",
			"\t\tif (a[x].l != -1) m_size += a[a[x].l].m_size;",
			"\t\tif (a[x].r != -1) m_size += a[a[x].r].m_size;",
			"\t}",
			"",
			"\tstruct splitter {",
			"\t\tint s;",
			"",
			"\t\tsplitter(int s) : s(s) {}",
			"",
			"\t\ttemplate<class N>",
			"\t\tbool operator() (vector<N>& a, int x) {",
			"\t\t\tint w = 1;",
			"\t\t\tif (a[x].l != -1) w += a[a[x].l].m_size;",
			"\t\t\treturn s >= w ? (s -= w, true) : false;",
			"\t\t}",
			"\t};",
			"};",
			"",
			"// Implement your treap policy here ",
			"struct treap_policy : treap_size, treap_sum<int> {",
			"\ttreap_policy(int x) {",
			"\t\tm_sum_root = m_sum_total = x;",
			"\t}",
			"",
			"\ttemplate<class N>",
			"\tvoid enter(vector<N>& a, int x) {",
			"",
			"\t}",
			"",
			"\ttemplate<class N>",
			"\tvoid pull(vector<N>& a, int x) {",
			"\t\ttreap_size::pull(a, x);",
			"\t\ttreap_sum::pull(a, x);",
			"\t}",
			"};"
		]
	}
}
