{
	"Planar point": {
		"scope": "cpp",
		"prefix": "point",
		"body": [
            "template<class P, class T = ll>",
            "T det(const P& a, const P& b, const P& c) {",
            "\treturn (a-b).template vp<T>(a-c);",
            "}",
            "",
            "template<class T>",
            "T sgn(T x) {",
            "\treturn x < 0 ? -1 : !!x;",
            "}",
            "",
            "template<class T>",
            "struct point {",
            "\tT x, y;",
            "\tpoint operator- (const point& b) const { return {x-b.x, y-b.y}; }",
            "\tpoint& operator-= (const point& b) { x -= b.x; y -= b.y; return *this; }",
            "\tbool operator< (const point& b) const { return tie(x, y) < tie(b.x, b.y); }",
            "\tbool operator== (const point& b) const { return tie(x, y) == tie(b.x, b.y); }",
            "\tbool operator<= (const point& b) const { return tie(x, y) <= tie(b.x, b.y); }",
            "\ttemplate<class R = ll> R sp(const point& b) const { return (R)x*b.x + (R)y*b.y; }",
            "\ttemplate<class R = ll> R vp(const point& b) const { return (R)x*b.y - (R)y*b.x; }",
            "};",
            "",
            "using pti = point<int>;",
            "using ptll = point<ll>;"
        ]
	},

    "Planar line segment": {
        "scope": "cpp",
		"prefix": "segment",
        "body": [
            "template<class T>",
            "struct segment {",
            "\tpoint<T> a, b;",
            "",
            "\tsegment(const point<T>& u, const point<T>& v) : a(u), b(v) {",
            "\t\tif (b < a) swap(a, b);",
            "\t}",
            "",
            "\ttemplate<class R = ll> R len2() { auto x = a-b; return x.template sp<R>(x); }",
            "",
            "\ttemplate<class R = ll>",
            "\tbool contains(const point<T>& c) const {",
            "\t\treturn !det(a, b, c) && a <= c && c <= b;",
            "\t}",
            "",
            "\t// Whether insides intersect at a nonzero angle",
            "\ttemplate<class R = ll>",
            "\tbool intersect_strict(const segment& o) const {",
            "\t\tR p = sgn(det(a, b, o.a)), q = sgn(det(a, b, o.b));",
            "\t\tR r = sgn(det(o.a, o.b, a)), s = sgn(det(o.a, o.b, b));",
            "\t\treturn p && q && r && s && p != q && r != s;",
            "\t}",
            "",
            "\t// Whether insides intersect in any way",
            "\ttemplate<class R = ll>",
            "\tbool intersect(const segment& o) const {",
            "\t\treturn intersect_strict(o) || contains(o.a) || contains(o.b)",
            "\t\t\t|| o.contains(a) || o.contains(b);",
            "\t}",
            "};"
        ]
    },

    "Planar polygon": {
        "scope": "cpp",
        "prefix": "polygon",
        "body": [
            "enum location { Inside, Outside, Boundary };",
            "",
            "template<class T = int>",
            "struct polygon {",
            "\tvector<point<T>> a;",
            "\ttemplate<class R = ll> R dbl_area() const { return abs(sgn_dbl_area()); }",
            "",
            "\ttemplate<class R = ll> R sgn_dbl_area() const {",
            "\t\tR s = R();",
            "\t\tfor (size_t i=1; i+1<a.size(); i++) s += det<point<T>, R>(a[0], a[i], a[i+1]);",
            "\t\treturn s;",
            "\t}",
            "",
            "\ttemplate<class R = ll>",
            "\tlocation operator() (const point<T>& p) const {",
            "\t\tint c = 0;",
            "\t\tfor (size_t i=0; i<a.size(); i++) {",
            "\t\t\tsize_t j = i+1 == a.size() ? 0 : i+1;",
            "\t\t\tauto u = a[i]-p, v = a[j]-p;",
            "\t\t\tif (!u.y && !v.y) {",
            "\t\t\t\tif ((u.x <= 0 && 0 <= v.x) || (v.x <= 0 && 0 <= u.x)) {",
            "\t\t\t\t\treturn Boundary;",
            "\t\t\t\t} else {",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t} else if (u.y && v.y) {",
            "\t\t\t\tif (sgn(u.y) == sgn(v.y)) continue;",
            "\t\t\t\tauto d = u.template vp<R>(v);",
            "\t\t\t\tif (!d) return Boundary;",
            "\t\t\t\tif ((d > 0) == (v.y > u.y)) continue;",
            "\t\t\t\tc += 2 * sgn(v.y);",
            "\t\t\t} else {",
            "\t\t\t\tif (!u.y) {",
            "\t\t\t\t\tif (u.x == 0) return Boundary;",
            "\t\t\t\t\tif (u.x < 0) c += sgn(v.y);",
            "\t\t\t\t} else {",
            "\t\t\t\t\tif (v.x == 0) return Boundary;",
            "\t\t\t\t\tif (v.x < 0) c -= sgn(u.y);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\treturn c ? Inside : Outside;",
            "\t}",
            "};"
        ]
    },

    "Convex hull": {
        "scope": "cpp",
        "prefix": "convexhull",
        "body": [
            "template<bool strict, class P, class T = ll>",
            "vector<P> half_hull(const vector<P>& a) {",
            "\tvector<P> b;",
            "\tfor (const P& p : a) {",
            "\t\twhile (b.size() >= 2) {",
            "\t\t\tauto d = det<P, T>(b[b.size() - 2], b.back(), p);",
            "\t\t\tif (strict ? d <= 0 : d < 0) {",
            "\t\t\t\tb.pop_back();",
            "\t\t\t} else {",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tb.push_back(p);",
            "\t}",
            "\treturn b;",
            "}",
            "",
            "template<bool strict, class P, class T = ll>",
            "vector<P> convex_hull(vector<P> a) {",
            "\tsort(begin(a), end(a));",
            "\tauto b = half_hull<strict, P, T>(a);",
            "\tb.pop_back();",
            "\treverse(begin(a), end(a));",
            "\tauto c = half_hull<strict, P, T>(a);",
            "\tc.pop_back();",
            "\tb.insert(b.end(), c.begin(), c.end());",
            "\treturn b;",
            "}"
        ]
    }
}
