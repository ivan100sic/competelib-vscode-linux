{
	"Aho-Corasick automaton": {
		"scope": "cpp",
		"prefix": "ahocorasick",
		"body": [
			"struct ahocorasick {",
			"\tstruct node {",
			"\t\tmap<char, int> next, hop;",
			"\t\tint link{0};",
			"\t};",
			"\tvector<node> b;",
			"\tbool done;",
			"\tahocorasick() : b(1), done(false) {}",
			"\tint size() const { return b.size(); }",
			"",
			"\tint operator+= (const string& s) {",
			"\t\tint y = 0;",
			"\t\tfor (char x : s) {",
			"\t\t\tauto it = b[y].next.find(x);",
			"\t\t\tif (it == b[y].next.end()) {",
			"\t\t\t\tit = b[y].next.insert(it, {x, b.size()});",
			"\t\t\t\tb.emplace_back();",
			"\t\t\t}",
			"\t\t\ty = it->second;",
			"\t\t}",
			"\t\tdone = false;",
			"\t\treturn y;",
			"\t}",
			"",
			"\tvoid bfs() {",
			"\t\tb[0].link = -1;",
			"\t\tvector<int> q(b.size());",
			"\t\tsize_t qs = 0, qe = 1;",
			"\t\twhile (qs != qe) {",
			"\t\t\tint x = q[qs++];",
			"\t\t\tfor (auto [c, y] : b[x].next) {",
			"\t\t\t\tint t = b[x].link;",
			"\t\t\t\twhile (t != -1 && !b[t].next.count(c))",
			"\t\t\t\t\tt = b[t].link;",
			"\t\t\t\tb[y].link = t != -1 ? b[t].next[c] : 0;",
			"\t\t\t\tq[qe++] = y;",
			"\t\t\t}",
			"\t\t}",
			"\t\tdone = true;",
			"\t}",
			"",
			"\tint operator() (int x, char c) {",
			"\t\tif (!done) bfs();",
			"\t\tauto it = b[x].hop.find(c);",
			"\t\tif (it == b[x].hop.end()) {",
			"\t\t\tint t = x;",
			"\t\t\twhile (t >= 0 && b[t].next.count(c) == 0)",
			"\t\t\t\tt = b[t].link;",
			"\t\t\tit = b[x].hop.insert(it, {c, t == -1 ? 0 : b[t].next[c]});",
			"\t\t}",
			"\t\treturn it->second;",
			"\t}",
			"};"
		]
	},

	"Suffix automaton": {
		"scope": "cpp",
		"prefix": "suffixautomaton",
		"body": [
			"template<class T = char>",
			"struct suffix_automaton {",
			"\tstruct node {",
			"\t\tmap<T, int> next;",
			"\t\tint link, len;",
			"\t\tbool cl;",
			"\t};",
			"",
			"\tvector<node> b;",
			"\tvector<int> _topo;",
			"",
			"\ttemplate<class U>",
			"\tsuffix_automaton(const U& s) {",
			"\t\tb.push_back({{}, -1, 0, false});",
			"\t\tint last = 0;",
			"\t\tfor (T x : s)",
			"\t\t\tlast = extend(x, last);",
			"\t}",
			"",
			"\tnode& operator[](int x) {",
			"\t\treturn b[x];",
			"\t}",
			"",
			"\tint extend(T x, int last) {",
			"\t\tint curr = b.size();",
			"\t\tb.emplace_back();",
			"\t\tb[curr].len = b[last].len + 1;",
			"\t\tint p = last;",
			"\t\tfor (; p != -1 && !b[p].next.count(x); p = b[p].link)",
			"\t\t\tb[p].next[x] = curr;",
			"\t\tif (p == -1) {",
			"\t\t\tb[curr].link = 0;",
			"\t\t} else {",
			"\t\t\tint q = b[p].next[x];",
			"\t\t\tif (b[p].len + 1 == b[q].len) {",
			"\t\t\t\tb[curr].link = q;",
			"\t\t\t} else {",
			"\t\t\t\tint clone = b.size();",
			"\t\t\t\tb.emplace_back(b[q]);",
			"\t\t\t\tb[clone].len = b[p].len + 1;",
			"\t\t\t\tb[clone].cl = true;",
			"\t\t\t\tfor (; p != -1 && b[p].next[x] == q; p = b[p].link)",
			"\t\t\t\t\tb[p].next[x] = clone;",
			"\t\t\t\tb[curr].link = b[q].link = clone;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn curr;",
			"\t}",
			"",
			"\tint operator()(int x, T y) {",
			"\t\tif (x == -1) return -1;",
			"\t\tauto it = b[x].next.find(y);",
			"\t\treturn it == b[x].next.end() ? -1 : it->second;",
			"\t}",
			"",
			"\tconst vector<int>& topo() {",
			"\t\tauto& v = _topo;",
			"\t\tif (!v.size()) {",
			"\t\t\tv.resize(b.size());",
			"\t\t\tiota(begin(v), end(v), 0);",
			"\t\t\tsort(begin(v), end(v), [&](int i, int j) { return b[i].len < b[j].len; });",
			"\t\t}",
			"\t\treturn v;",
			"\t}",
			"",
			"\ttemplate<class F, class G>",
			"\tauto dp_tree(F f, G g) {",
			"\t\tauto& t = topo();",
			"\t\tint n = b.size();",
			"\t\tvector<decltype(f(0))> v(n);",
			"\t\tfor (int i=0; i<n; i++)",
			"\t\t\tv[i] = f(i);",
			"\t\tfor (int i=n-1; i; i--) {",
			"\t\t\tint y = t[i], x = b[y].link;",
			"\t\t\tv[x] = g(v[x], v[y]);",
			"\t\t}",
			"\t\treturn v;",
			"\t}",
			"",
			"\tvector<int> firstpos() {",
			"\t\treturn dp_tree(",
			"\t\t\t[&](int i) { return b[i].cl ? numeric_limits<int>::max() : b[i].len; },",
			"\t\t\t[](int x, int y) { return min(x, y); });",
			"\t}",
			"",
			"\tvector<int> lastpos() {",
			"\t\treturn dp_tree(",
			"\t\t\t[&](int i) { return b[i].cl ? numeric_limits<int>::max() : b[i].len; },",
			"\t\t\t[](int x, int y) { return max(x, y); });",
			"\t}",
			"",
			"\tvector<int> endpos_size() {",
			"\t\treturn dp_tree([&](int i) { return 1 - b[i].cl; }, plus<int>());",
			"\t}",
			"};"
		]
	},

	"Substring comparator": {
		"scope": "cpp",
		"prefix": "substringcompare",
		"body": [
			"struct substring_compare {",
			"\tvector<vector<int>> cc;",
			"",
			"\tint re(int x, int n) { return x >= n ? x - n : x; }",
			"",
			"\tsubstring_compare(const string& s) {",
			"\t\tint n = s.size(), sz = 0;",
			"\t\tvector<int> c(begin(s), end(s)), p(n);",
			"\t\tvector<vector<int>> g(max(n, 128));",
			"\t\tfor (int i=0; i<n; i++) {",
			"\t\t\tg[c[i]].push_back(i);",
			"\t\t}",
			"\t\tfor (auto& gr : g) {",
			"\t\t\tfor (int i : gr) {",
			"\t\t\t\tp[sz++] = i;",
			"\t\t\t}",
			"\t\t\tgr.clear();",
			"\t\t}",
			"\t\tfor (int h=1; h<n; h*=2) {",
			"\t\t\tcc.push_back(c);",
			"\t\t\tvector<int> pn(n), cn(n);",
			"\t\t\tfor (int j : p) {",
			"\t\t\t\tint jp = re(j+n-h, n);",
			"\t\t\t\tg[c[jp]].push_back(jp);",
			"\t\t\t}",
			"\t\t\tsz = 0;",
			"\t\t\tfor (auto& gr : g) {",
			"\t\t\t\tfor (int i : gr) {",
			"\t\t\t\t\tpn[sz++] = i;",
			"\t\t\t\t}",
			"\t\t\t\tgr.clear();",
			"\t\t\t}",
			"\t\t\tcn[pn[0]] = 0;",
			"\t\t\tint nc = 1;",
			"\t\t\tfor (int i=1; i<n; i++) {",
			"\t\t\t\tint s0 = pn[i-1], s1 = pn[i];",
			"\t\t\t\tif (c[s1] == c[s0] && c[re(s1+h, n)] == c[re(s0+h, n)]) {",
			"\t\t\t\t\tcn[s1] = nc - 1;",
			"\t\t\t\t} else {",
			"\t\t\t\t\tcn[s1] = nc++;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tswap(c, cn);",
			"\t\t\tswap(p, pn);",
			"\t\t}",
			"\t}",
			"",
			"\tstruct substring {",
			"\t\tsubstring_compare* ctx;",
			"\t\tint l, r;",
			"",
			"\t\tint cmp(const substring& o) const {",
			"\t\t\tint tw = r - l, ow = o.r - o.l, tl = l, ol = o.l;",
			"\t\t\tint w = min(tw, ow);",
			"\t\t\tfor (size_t i=0; i<ctx->cc.size(); i++) {",
			"\t\t\t\tif (w & (1 << i)) {",
			"\t\t\t\t\tif (int d = ctx->cc[i][tl] - ctx->cc[i][ol]; d) {",
			"\t\t\t\t\t\treturn d; ",
			"\t\t\t\t\t}",
			"\t\t\t\t\ttl += 1 << i;",
			"\t\t\t\t\tol += 1 << i;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn tw - ow;",
			"\t\t}",
			"",
			"\t\tbool operator< (const substring& o) const {",
			"\t\t\treturn cmp(o) < 0;",
			"\t\t}",
			"",
			"\t\tbool operator== (const substring& o) const {",
			"\t\t\treturn cmp(o) == 0;",
			"\t\t}",
			"\t};",
			"",
			"\tsubstring operator() (int l, int r) {",
			"\t\treturn {this, l, r};",
			"\t}",
			"};"
		]
	}
}